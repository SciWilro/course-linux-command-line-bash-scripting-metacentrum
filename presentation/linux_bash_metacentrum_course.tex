\documentclass[compress, ucs, xelatex, 11pt, xcolor=svgnames,
  hyperref={
    bookmarks=true,
    unicode=true,
    colorlinks=true,
    pdftitle={Linux, command line and MetaCentrum},
    plainpages=false,
    pdfauthor={Vojtech Zeisek},
    pdfsubject={Course about use of Linux command line, writing shell scripts and using MetaCentrum of CESNET},
    pdfcreator={XeLaTeX},
    pdfkeywords={Linux, GNU, BASH, shell, command line, MetaCentrum},
    linkcolor=Red,
    anchorcolor=Blue,
    citecolor=Purple,
    filecolor=DodgerBlue,
    menucolor=DarkOrchid,
    urlcolor=DeepSkyBlue,
    pdftex},
  url={hyphens, lowtilde} % Allow line breaks within URLs
  ]{beamer}

% Theme settings
\usetheme[secheader]{Boadilla}
\usecolortheme{wolverine}
\setbeamertemplate{headline} {
  \begin{beamercolorbox}{section in head/foot}
    \insertsectionnavigationhorizontal{\paperwidth}{\hskip0pt plus1fill}{\hskip0pt plus1fill}
  \end{beamercolorbox}
  \begin{beamercolorbox}[ht=2ex, dp=1.125ex]{subsection in head/foot}
    \insertsubsectionnavigationhorizontal{\paperwidth}{}{\hfill\hfill}
  \end{beamercolorbox}
  }
\useinnertheme{circles}

% Basic packages
\usepackage{xltxtra} % Loads following 3 packages for processing with XeLaTeX
\usepackage{metalogo}
\usepackage{xunicode}
\usepackage{fontspec}

% Othe packages
\usepackage{multicol}
\usepackage{tabularx}

% In-line higlighting
\usepackage{soul}

% Add background for \texttt{} (using pacakge soul)
\sethlcolor{Beige}
\renewcommand{\texttt}[1]{\hl{\ttfamily #1}}

% Change text color of highlighted text back to red
\renewcommand{\alert}[1]{\textcolor{red}{#1}}

% Syntax higlight
\usepackage{minted}
\usemintedstyle{vim} % Styles are listed by pygmentize -L styles; languages are listed by pygmentize -L lexers
\newminted{bash}{linenos, fontsize=\footnotesize, bgcolor=Beige, fontfamily=tt, gobble=4, numbersep=-3pt}
% Change line number style
\renewcommand{\theFancyVerbLine}{
  \sffamily
  \textcolor{BlueViolet}{
    \tiny
    \oldstylenums{
      \arabic{FancyVerbLine}
      }
    }
  }
% Inline source code
\newmint{bash}{fontsize=\footnotesize, bgcolor=Beige}

% Default language
\usepackage{polyglossia}
\setdefaultlanguage{english}

% Title page
\author{Vojtěch Zeisek}
\institute[\url{https://trapa.cz/}]{Department of Botany, Faculty of Science, Charles University, Prague\\Institute of Botany, Czech Academy of Sciences, Průhonice\\\url{https://trapa.cz/}, \href{mailto:zeisek@natur.cuni.cz}{zeisek@natur.cuni.cz}}
\title{Linux, command line \& MetaCentrum}
\subtitle{Use of Linux command line not only for MetaCentrum of CESNET}
\titlegraphic{\includegraphics[width=2cm]{tux.png}}
\date{January 26 and 27, 2017}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[allowframebreaks]{Outline}
\tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}{The course information}
  \begin{itemize}
    \item The course page: \url{https://trapa.cz/en/course-linux-command-line-2017}
    \begin{itemize}
      \item Česky: \url{https://trapa.cz/cs/kurz-prikazove-radky-linuxu-2017}
    \end{itemize}
    \item Subject in SIS: \url{https://is.cuni.cz/studium/eng/predmety/index.php?do=predmet&kod=MB120C17}
    \begin{itemize}
      \item Česky: \url{https://is.cuni.cz/studium/predmety/index.php?do=predmet&kod=MB120C17}
      \item For students having subscribed the subject, active participation and presence whole course is required
    \end{itemize}
    \item Working version is available at \url{https://github.com/V-Z/course-r-mol-data} -- feel free to contribute, request new parts or report bugs
  \end{itemize}
\end{frame}

\begin{frame}{Materials to help you\ldots}
\begin{itemize}
 \item Download the presentation \url{https://soubory.trapa.cz//linuxcourse/linux_bash_metacentrum_course.pdf}
 \item Download the scripts and toy data \url{https://soubory.trapa.cz//linuxcourse/scripts.zip}
 \begin{itemize}
  \item \alert{Note:} Open the scripts in some \alert{good} \href{http://texteditors.org/cgi-bin/wiki.pl?PickingATextEditor}{text editor} -- showing syntax highlight, line numbers, etc. (\alert{NO} Windows notepad); the file is in UTF-8 encoding and with UNIX end of lines (so that too silly programs like Windows notepad won't be able to open it correctly)
  \item \alert{Never ever} open any script file in software like MS~Word -- they destroy quotation marks and other things by ``typographical enhancements'' making the script unusable
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Virtual machine for learning}
  \begin{multicols}{2}
    \begin{itemize}
      \item If you do not have Linux installed, download VirtualBox from \url{https://www.virtualbox.org/}
      \item Download openSUSE Leap 42.2 Linux distribution for this course from \url{ftp://botany.natur.cuni.cz/openSUSE_Leap_Linux_course.ova} (3.7~GB)
      \item Launch VirtualBox and go to menu \textbf{File | Import appliance\ldots} to import it. When do, launch it (\textbf{Start})
    \end{itemize}
    \includegraphics[height=6cm]{virtualbox.png}
  \end{multicols}
\end{frame}

\begin{frame}[allowframebreaks]{What it is UNIX, Linux and GNU\ldots}
\begin{itemize}
  \item UNIX
  \begin{itemize}
    \item Originally developed in Bell labs of AT\&T in 1696, written in C, since then  huge radiation, hybridization, HGT,~\ldots
    \item Trademark -- only systems passing certain conditions (paid certification) can be called ``UNIX'' -- Solaris, HP-UX, AIX, etc. -- commercial systems for big servers
    \item Main principles: simple, multitasking, hierarchical, network, for more users (takes cares about permissions etc.), configuration written in plain text files, important relationships among applications (generally one application = one task -- they are chained), work primarily with text, has kernel and API (interface to communicate with the rest of the system)
    \item UNIX-like (UN*X) -- systems compatible with UNIX (Linux, BSD and its variants, Mac OS X,~\ldots)
    \begin{itemize}
      \item Mainly open-source (UNIX is commonly commercial -- source code is not available, but specification is)
      \item Nowadays prevailing over ``old'' UNIX systems, used in many devices from tiny embedded toys to huge data centers
      \item Try to provide same service as paid systems, but (mostly) for free
    \end{itemize}
    \item Many courts about copyrights, parts of code, patents -- USA allow software patents, EU not -- GNU, Linux, BSD, etc. try to ensure to have only code not covered by any patents to avoid possible courts
  \end{itemize}
  \item \href{https://www.gnu.org/}{GNU}
  \begin{itemize}
    \item ``GNU's Not Unix!'' -- but they are compatible
    \item Since 1984 Richard Stallman (founder of \href{https://www.fsf.org/}{Free Software Foundation}) tried to make new kernel (Hurd -- not finished yet\ldots)
    \item Generally set of basic system tools -- working with many kernels (Linux BSD*, Mac's Darwin,~\ldots), also present in many commercial paid UNIX systems
    \item Source code is free -- anyone can study it (Security!), report bugs, contribute, modify, share it,~\ldots
    \item GNU General Public License (GPL) -- free spirit of open-source -- license, idea, how to share software
  \end{itemize}
  \item Linux
  \begin{itemize}
    \item First version of kernel written by Linus Torvalds in Helsinki in 1991
    \item Kernel was in principle inspired by various UNIX systems and using GNU tools for work
    \item Quickly became popular -- anyone can take it and use for any needs
    \item Used in small embedded (commonly network) devices, mobile devices (book readers, Android,~\ldots), personal computers, servers (from home level to biggest data centers),~\ldots
    \item Nowadays powering most of the Internet
    \item Anyone can contribute -- not only code, also documentation, design, translations,~\ldots
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Extremely simplified UNIX phylogeny}
\begin{center}
  \includegraphics[height=7cm]{unix_history-simple.png}
\end{center}
\end{frame}

\subsection{Licenses and money}

\begin{frame}{Cathedral vs. market place}{What is principal difference between free open-source and commercial software}
\begin{itemize}
  \item Commercial software is like a cathedral
  \begin{itemize}
    \item Pay big money and get it in the state which the architect like
    \item User can not modify it (or it is terribly expensive)
    \item Might be you don't need everything -- but still paying whole set
  \end{itemize}
  \item Free open-source software (FOSS) is like a market place
  \begin{itemize}
    \item Find there many producers of same tools -- pick up those you like -- freedom of choice
    \item Take exactly the tools you need -- any combination is possible
    \item Much cheaper to shop there
  \end{itemize}
  \item Both have pros and cons -- depends what you wish\ldots
\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Free and open-source software}
\begin{itemize}
  \item \textbf{Free like freedom of speech, \alert{not} like free beer!}
  \item Not every OSS (generally less strict conditions) has to be \textbf{F}OSS (you can do with it (almost) whatever you like) -- source code might be available under some circumstance (only to look), but modification and/or reuse of the code prohibited (and then it is not \textbf{free})
  \item Open-source -- source code can be seen by the holder of the license -- many variants what he can do with the code then
  \item GNU GPL (``\href{https://www.gnu.org/copyleft/}{copyleft}'') -- probably most common OSS license, strict, viral -- derived code has to keep the license -- surprisingly not fully ``free'' as it doesn't allow changes of license
  \item LGPL -- Lesser GPL -- more permissive
  \item BSD license -- permissive -- allow derived code to became closed-source (commonly used by Apple Mac OS X, Safari browser,~\ldots)
  \item Apache license, Mozilla license,~\ldots{ }-- many variants for specific use in particular software
  \item Creative Commons (CC) -- software licenses above not suitable for multimedia, text, etc. -- CC has many options (including denial of reuse of the product), see \url{https://creativecommons.org/}
  \item And many more\ldots
  \item Orientation might be tricky, but practical output for users is more or less same -- the software can be independently checked for bugs, backdoors, malware, can be improved and under some circumstances, new software can be derived, and usually, it is available for free
  \item Aim is to ``liberate'' software to keep open sharing of ideas, mutual improve and security control -- although the point is clear, there are debates how to reach it\ldots
\end{itemize}
\end{frame}

\begin{frame}{How to make money with free open-source software?}
\begin{itemize}
  \item Traditional model -- user rents right (``buys a license'') to use the software (and sometimes for support -- usually for extra money)
  \item Common mistake -- software is not ``bought'' -- only license is rented
  \item Software as service
  \begin{itemize}
    \item (F)OSS is available for free -- user can use it as it is or buy a support -- help
    \item No vendor lock-in -- user has the code, so he can modify the software himself, change provider of the services,~\ldots
    \item Cheap for user as well as company -- company specialized for one task, let's say server database, doesn't have to take care about the rest of the system -- someone else does; user pays only what he needs
    \item Our faculty is using \href{https://plone.org/}{Plone} system for web pages -- anyone can use it for free, someone (like we) found company to help, and if we'd decided, we  could keep Plone and maintain it ourselves or find another company to help us with it
  \end{itemize}
\end{itemize}
\end{frame}

\section{Linux}

\begin{frame}{What it is a ``Linux''}
\begin{itemize}
  \item Operating system respecting principles of UNIX
  \item Components
  \begin{itemize}
    \item Linux kernel -- basic part of the system responsible for hardware and very basic low-level running of the system (``Linus \textit{sensu stricto}'')
    \item GNU core utilities -- basic applications
    \item Graphical user environment (GUI) -- many choices
    \item Many other applications -- according to use -- whatever imaginable
  \end{itemize}
  \item Linux distribution? (``Linux \textit{senso lato}'')
  \begin{itemize}
    \item Somehow assemble Linux kernel, basic tools and some applications
    \item Optionally add some patches and extra tools and gadgets
    \item Make your own design! (very important)
    \item If lazy, remake existing distribution ;-) (using e.g. \href{https://susestudio.com/}{web service})
    \item Still surprised there are hundreds of them?
    \item It is like Lego -- pieces are more or less same across distributions, but result is very variable
    \item From ``general'' for daily use (pick up whatever you like) to very specialized -- special hardware devices, network services, rescue,~\ldots
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Linux kernel and other part around it}
  \includegraphics[width=\textwidth]{linux_kernel_ubiquity.png}\\
  \url{https://en.wikipedia.org/wiki/Linux_distribution}
\end{frame}

\begin{frame}{Extremely simplified adaptive radiation of Linux distributions}
  \includegraphics[width=\textwidth]{linux_fylogen_2.png}\\
  \url{https://en.wikipedia.org/wiki/List_of_Linux_distributions} and \url{https://distrowatch.com/} ($\sim$800 distributions, $\sim$260 active)
\end{frame}

\subsection{Choose one}

\begin{frame}{Most common Linux distributions}
\begin{itemize}
  \item \href{http://distrowatch.com/search.php?package=DEB}{Debian (DEB) based}
  \begin{itemize}
    \item \href{https://www.debian.org/}{Debian} -- one of oldest and most common, especially on servers
    \item \href{http://www.ubuntu.com/}{Ubuntu} (nowadays probably the most popular on PCs and notebooks) and derivatives -- \href{https://www.kubuntu.org/}{Kubuntu}, \href{https://xubuntu.org/}{Xubuntu}, \href{http://lubuntu.net/}{Lubuntu},~\ldots~(according to GUI used -- most of the system is same)
    \item \href{http://linuxmint.com/}{Mint} -- Based on Ubuntu as well as Debian, very user-friendly
    \item Kali, KNOPPIX,~\ldots
  \end{itemize}
  \item \href{http://distrowatch.com/search.php?package=RPM}{Red Hat (RPM) based}
  \begin{itemize}
    \item \href{https://www.redhat.com/}{Red Hat} -- probably the most common commercial
    \item \href{https://getfedora.org/}{Fedora} -- ``playground'' for Red Hat -- very experimental
    \item \href{https://www.centos.org/}{Centos} -- Clone of Red Hat
    \item \href{https://www.opensuse.org/}{openSUSE} -- SUSE is second largest Linux company, openSUSE is community distribution (free) companion of SUSE Linux Enterprise
    \item Scientific Linux, Mageia, PCLinuxOS,~\ldots
  \end{itemize}
  \item Android
  \item For experienced users: Arch, Slackware, Gentoo,~\ldots
\end{itemize}
\end{frame}

\begin{frame}{Graphical User Interfaces}{More like ``Mac-style'', ``Windows-style'' or something else? Feature rich or minimalistic?}
\begin{itemize}
  \item Most of GUIs are available for most of common distributions -- one is picked as default and ``only'' color style is different
  \item \href{https://unity.ubuntu.com/}{Unity} -- developed by Ubuntu, relatively specific (not common outside Ubuntu), ``Mac-style''
  \item \href{https://www.kde.org/}{KDE} -- one of the most common, feature extremely rich, basically ``Windows-like'' (can be changed)
  \item \href{https://www.gnome.org/}{GNOME} -- one of the most common, relatively simplistic interface, but still feature rich, ``Mac-like''
  \item \href{http://xfce.org/}{XFCE} -- lightweight version of older GNOME -- for older computers or users not willing to be disturbed by graphical effects, basically ``Mac-like'' looking, but panels can be moved to ``Windows style''
  \item \href{http://cinnamon.linuxmint.com/}{Cinnamon} -- remake of GNOME to look more like Windows\ldots
  \item And much more\ldots
  \item Choose what you like -- doesn't matter much which one\ldots
\end{itemize}
\end{frame}

\begin{frame}{Ubuntu with Unity}
\begin{center}
  \includegraphics[height=7cm]{ubuntu.png}
\end{center}
\end{frame}

\begin{frame}{openSUSE with KDE -- Kubuntu is same, but blue\ldots}
\begin{center}
  \includegraphics[height=7cm]{opensuse.png}
\end{center}
\end{frame}

\begin{frame}{Fedora with GNOME}
\begin{center}
  \includegraphics[height=7cm]{fedora.png}
\end{center}
\end{frame}

\begin{frame}{Linux Mint with Cinnamon}
\begin{center}
  \includegraphics[height=7cm]{mint.png}
\end{center}
\end{frame}

\begin{frame}{Debian with XFCE -- Xubuntu has more ``modern'' design}
\begin{center}
  \includegraphics[height=7cm]{debian.png}
\end{center}
\end{frame}

\begin{frame}{How to try it?}
\begin{itemize}
  \item Install it on some computer together with or instead of Windows
  \begin{itemize}
    \item If you can use whole disk, just boot from CD/USB and click ``Next''\ldots
    \item If you don't have whole disk, you need at least one (commonly more) disk partition(s) -- if you don't know how to manage them, ask someone skilled\ldots
  \end{itemize}
  \item Live CD/USB
  \begin{itemize}
    \item The most easy -- burn ISO image of CD from web of almost any Linux distribution or use for example \href{https://unetbootin.github.io/}{UNetbootin} to prepare bootable flash
    \item You only have to know how to boot from CD/USB (usually press \texttt{ESC}, \texttt{DEL}, \texttt{F2}, \texttt{F10}, \texttt{F12},~\ldots~when starting computer -- varies according to manufacturer)
  \end{itemize}
  \item Virtualization
  \begin{itemize}
    \item Requires relatively powerful computer (preferable Intel i5 or i7 and over 4~GB of RAM)
    \item Install virtual machine (probably the most easy is \href{https://www.virtualbox.org/}{VirtualBox}) -- allows install and run another operating system inside host as an ordinary application -- very easy and comfortable
  \end{itemize}
\end{itemize}
\end{frame}

\subsection{Differences}

\begin{frame}{The Linux diversity\ldots}
\begin{itemize}
  \item Try several distributions and just choose one you like\ldots
  \item Unless selecting among the most common, it doesn't matter much which one you pick up
  \item Which design do you like?
  \item Which distribution is your friend or colleague using? To have someone to ask for help\ldots :-)
  \item You can change GUI (or its design) without change of distribution
  \item Applications are still same -- no difference in Firefox across distributions -- keep your settings when changing distribution
  \item Everyone using Android is using Linux ;-)
  \item Special use -- \href{http://www.freenas.org/}{FreeNAS} for home as well as business file servers, \href{https://partedmagic.com/}{Parted Magic} and/or \href{https://www.system-rescue-cd.org/SystemRescueCd_Homepage}{SystemRescueCD} to repair broken system (disk failure) and save data,~\ldots
\end{itemize}
\end{frame}

\begin{frame}{Differences among (common) Linux distributions}
\begin{itemize}
  \item Design and colors ;-)
  \item Default GUI
  \item Applications available right after installation
  \item Default settings (not much)
  \item Package management -- especially in command line
  \item Management of system services (how to start/stop certain server service like database or web) -- not important for daily usage for most of users
  \item Sometimes in location of some configuration files (for system services) -- also not important in daily usage of most of users
  \item Kernel is almost same, applications are used in same way
  \item Command line is almost same across Linux, and almost same as in other UNIX systems
\end{itemize}
\end{frame}

\section{UN*X}

\subsection{Basic theory of operating system}

\begin{frame}{Short overview of hard disk layout}
\begin{itemize}
  \item Physical disk (piece of hardware) has at least 1 partition -- division seen in Windows as ``disks'' (\texttt{C}, \texttt{D},~\ldots) and mounted directory in UNIX
  \item MBR -- older description of disk division, up to 4 primary partitions (OS typically requires at leas one to run), one can be extended and contain more partitions, disks up to 2 TB
  \item GPT -- newer, no relevant limits, requires UEFI (replacement of BIOS in newer computers)
  \item If unsure what to do, high probability to break it\ldots
  \item Blank new partition has to be formatted to desired file system according to use and target operating system
  \item Linux distributions have easy graphical tools to manage disk partitions
  \item Always have backup before such management!
\end{itemize}
\end{frame}

\begin{frame}{Put together more disks}
\begin{itemize}
  \item \href{https://en.wikipedia.org/wiki/RAID}{RAID} -- Redundant Array of Inexpensive/Independent Disks
  \item RAID~0 -- stripping, no redundancy, no security, speed up (two or more disks joined into one, files divided among disks)
  \item RAID~1 -- mirroring -- even number of disks of same size -- resulting capacity is half, very fast, secure
  \item RAID~5 -- at least three disks, one is used for parity control, little bit slower
  \item Combinations (RAID~10,~\ldots)
  \item \href{https://en.wikipedia.org/wiki/Logical_volume_management}{LVM} -- Logical Volume Management -- built over several partitions/disks -- seen by OS as one continuous space, can be dynamically managed
  \item Functionality of RAID and LVM (and more) is more or less covered by XFS and Btrfs (next slide)
\end{itemize}
\end{frame}

\begin{frame}{File systems}
\begin{center}
\begin{footnotesize}\begin{tabular}{ccccccc}
\textbf{FS name} & \begin{tabular}[x]{@{}c@{}}\textbf{Name}\\\textbf{length}\end{tabular} & \begin{tabular}[x]{@{}c@{}}\textbf{Characters}\\\textbf{in file name}\end{tabular} & \begin{tabular}[x]{@{}c@{}}\textbf{Path}\\\textbf{length}\end{tabular} & \textbf{File size} & \begin{tabular}[x]{@{}c@{}}\textbf{Partition}\\\textbf{size}\end{tabular} & \textbf{Systems}\\
FAT32 & 255 & Unicode & No limit & 4 GiB & 2 TiB & Any\\
exFAT & 255 & ? & No limit & 16 EiB & 64 ZiB & Any\\
NTFS & 255 & Variable & Variable & 16 TiB & 16 EiB & \begin{tabular}[x]{@{}c@{}}Windows,\\read-write\\in UN*X\end{tabular}\\
HFS+ & 255 & Unicode & ? & 8 EiB & 8 EiB & Mac OS\\
ext4 & 255 & Any, not / & No limit & 16 TiB & 1 EiB & UN*X\\
XFS & 255 & Any & No limit & 9 EiB & 9 EiB & UN*X\\
Btrfs & 255 & Any & ? & 16 EiB & 16 EiB & UN*X\\
\end{tabular}
\end{footnotesize}
\end{center}
\begin{itemize}
  \item FAT32 (including extensions) is old-fashioned and not reliable FS
  \item NTFS, FAT do not support UNIX permissions, so they can't be used as system partition in Linux
  \item ext4, XFS and Btrfs are not accessible in Windows
  \item XFS and Btrfs are the most advanced FS in common use
\end{itemize}
\end{frame}

\begin{frame}[fragile]{File names}
\begin{itemize}
  \item Linux allow \alert{any} character in file name, except \alert{slash} (\texttt{/}), so including anything on keyboard as well as line break (!). Be conservative\ldots
\end{itemize}
  \begin{bashcode}
    mkdir My New Directory # Produces THREE directories (mkdir creates
                           # directories; spaces separate parameters)
                           # Solutions:
    mkdir "My New Directory" # (you can use simple quotes '...' as well) or
    mkdir My\ New\ Directory # "\" escapes following character
    rmdir My\ New\ Directory # Same problem and solution when removing it
    touch \* # Creates new empty file named just *
    rm * # What would be removed? :-)
    rm \* # This works...
  \end{bashcode}
\begin{itemize}
  \item Files and directories starting by \alert{dot} (\texttt{.}) are hidden by default (typically user settings and application data in user home)
\end{itemize}
  \begin{bashcode}
    touch .hiddenfile # Let's make empty text file hidden by default
    ls # We will not see it
    ls -a # We will see it
  \end{bashcode}
\end{frame}

\begin{frame}[allowframebreaks]{Directory structure in Linux}
\begin{itemize}
  \item Similar in another UN*X systems
  \item Top directory ``\texttt{/}'' -- ``root''
  \item Everything else (including disks and network shares) are mounted in subdirectories (/\ldots)
  \item \texttt{/bin} -- very basic command line utilities
  \item \texttt{/boot} -- bootloader responsible for start of system
  \item \texttt{/dev} -- devices -- disks, CD, RAM, USB devices,~\ldots
  \item \alert{\texttt{/etc}} -- system configuration in plain text files -- edit them to change settings (read documentation and comments there)
  \item \alert{\texttt{/home}} -- users' homes
  \item \texttt{/lib}, \texttt{/lib64} -- basic system libraries
  \item \texttt{/lost+found} -- feature of FS, after crash and recovery of FS, restored files are there
  \item \alert{\texttt{/media}} -- attached disks (USB flash,~\ldots) usually appear there (might be in \texttt{/var/run/media}) -- subdirectories are automatically created when device is plugged and disappears when unplugged
  \item \texttt{/mnt} -- usually manually mounted file systems (but can it can be mounted elsewhere)
  \item \texttt{/opt} -- optional, usually locally compiled software
  \item \texttt{/proc} -- dynamic information about system processes
  \item \texttt{/root} -- root's (admin's) home
  \item \texttt{/sbin} -- basic system utilities
  \item \texttt{/selinux} -- SELinux is security framework
  \item \texttt{/srv} -- FTP and WWW server data (can be in \texttt{/var/srv})
  \item \texttt{/sys} -- basic system
  \item \texttt{/tmp} -- temporary files -- users have private dynamically created spaces there
  \item \texttt{/usr} -- binaries (executable applications) and libraries of installed applications
  \item \alert{\texttt{/var}} -- data of most of applications and services, including e.g. database data, system logs,~\ldots
  \item \alert{\texttt{/windows}} -- if on dual boot, Windows disks are commonly mounted here
  \item Can be altered, modified
  \item Usually, work only in your home, anywhere else modify files only if you are absolutely sure what you are doing
  \item Normal user doesn't have permission to modify files outside his directory (with exception of plugged removable media)
  \item Try \texttt{man hier} for details
\end{itemize}
\end{frame}

\begin{frame}{Configuration in /etc (examples)}
\begin{itemize}
  \item Configuration of system services (servers,~\ldots) and behavior
  \begin{itemize}
    \item Apache web server, database, FTP server, networking, basic system settings,~\ldots
  \end{itemize}
  \item \texttt{cron*} -- cron automatically repeatedly runs tasks
  \item \texttt{fstab} -- description of mounted FS
  \item \texttt{group} -- list of users and groups
  \item \texttt{passwd} -- basic settings of for users (home directory, default shell,~\ldots)
  \item \texttt{resolv.conf} --  DNS settings (part of basic networking)
  \item \texttt{shadow} -- users passwords in encrypted format
  \item \texttt{skel} -- basic directories and configuration for new users
  \item Much more\ldots
\end{itemize}
\end{frame}

\begin{frame}{Types of files}
\begin{itemize}
  \item \bash/ls -la/
  \item Regular file -- ordinary file, marked by \texttt{-}
  \item Directory -- in UNIX special type of file, marked by \texttt{d}
  \item Symbolic link (symlink, ``soft link'') -- points to another place, marked by \texttt{l}, slide \ref{links}
  \item Hard link -- just another name for existing file, no special symbol, slide \ref{links}
  \item Block and character device -- in \texttt{/dev}, representations of devices (hard disks, terminals,~\ldots), marked by \texttt{b} or \texttt{c} respectively
  \item Named pipe -- pipe can be saved (by \texttt{mkfifo}), looks like a file, more at slide \ref{pipe}
  \item Socket -- for communication among processes, also bidirectional, available on network
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Login to remote server}
\begin{multicols}{2}
  \vfill
  SSH -- secure shell -- encrypted connection
  \vfill
  \begin{bashcode}
    ssh remoteUser@remote.server.cz
    # When logging first time, check
    # and confirm fingerprint key
    yes # And press Enter
    # Type remote user's password
    # (nothing is shown when typing)
    # Confirm by Enter
  \end{bashcode}
  \vfill
  Our toy server: user names from \texttt{u01} to \texttt{u30}, password: \texttt{Cuser1}
  \vfill
  \bash/ssh uXY@vyuka.natur.cuni.cz/
  \vfill
  If fingerprint key changes, ssh complains a lot -- possible \href{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{man in the middle attack}
  \vfill
  \begin{center}
    \includegraphics[height=6.5cm]{putty.png}
  \end{center}
\end{multicols}
\end{frame}

\subsection{Permissions}

\begin{frame}{File permissions}
\begin{itemize}
  \item Combination of permissions to read/write/execute for user(owner)/group/others
\end{itemize}
\begin{center}
\begin{tabular}{llll}
\textbf{Permission} & \textbf{Number} & \textbf{Directory} & \textbf{File}\\
r & 4 & Read content & Read content\\
w & 2 & Write into it & Write into it\\
x & 1 & Enter it & Launch application \\
\end{tabular}
\end{center}
\begin{itemize}
  \item \texttt{rwxr-wr--} -- 3*3 characters for permissions for owner of the file/directory, group it is belonging to, and other users (\texttt{d} on beginning marks directories, \texttt{l} links, \texttt{+} ACL, slide \ref{acl})
  \item \texttt{764} -- same as above --- numbers for each role are summed -- first one is for owner, second for group and last for others
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Permission examples}
  \begin{bashcode}
    ls -l
    # Only owner can read and write the file; 600
    -rw-------   1 vojta users   38211 20. led 09.23 .bash_history
    # Owner can write read and write the file, others read; 644
    -rw-r--r--   1 vojta users    2707 29. lis 16.21 .bashrc
    # Owner can enter, read and write directory, others can read
    # and enter it; 755
    drwxr-xr-x  41 vojta users    4096 27. pro 09.55 bin
    # Only owner can read, write and enter the directory,
    # others nothing; 700
    drwx------  58 vojta users    4096 17. pro 15.45 .config
    # Link, everyone can do everything; 777
    lrwxrwxrwx   1 vojta users      37 20. led 09.33 .lyxpipe.in ->
      /tmp/kde-vojta/kilemj7d3E/.lyxpipe.in
    # Executable (application) - everyone can launch it, but only
    # owner can write into the file; 755
    -rwxr-xr-x   1 vojta users    2187 27. lis 13.10 strap.sh*
  \end{bashcode}
  \vfil
  \begin{itemize}
    \item Permission to ``write'' also means permission to \textbf{delete} it
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Check and modify permissions}
  \begin{bashcode}
    ls -l # Long list - file names and attributes
    ls -a # All, including hidden files (starting with dot)
    ls -F # Add on the end of name "/" for directories and "*"
          # for executable
    ls -h # Human readable size units (use with -l or -s)
    ls --color ## Coloured output
    ls -laFh --color # Combine any parameters you like
    chmod u/g/o/a+/-r/w/x FILE # For respective user/group/others/all
                               # adds/removes permission to
                               # read/write/execute
    chmod XYZ FILE # Instead of XYZ use number code of permission
    chmod -R # Recursive (including subdirectories)
    chmod +x script.sh # Make script.sh executable for everyone
    chmod o-r mydir # Remove read permission from others on mydir
    chmod 600 FILE1 FILE2 # Make both files readable and
                          # writable only by their owner
    chmod 000 FILE # No one can do anything - owner or root must add
                   # some permissions before any manipulation...
    chmod 777 * # All permissions for everyone on everything
  \end{bashcode}
\end{frame}

\begin{frame}[fragile, label=acl]{Extending permissions -- ACL}{Access control list}
\begin{itemize}
  \item By default, it is not possible to give specific permission to the user who is not owner, nor member of group owing the file
  \item In ext4 FS it has to be turned on manually (usually it is by default), it is part of XFS and Btrfs
  \item Command \texttt{getfacl} lists those extra permissions
  \item When in use, ``basic'' tools listing permissions (e.g. \texttt{ls -l}, ACL in use is marked by \texttt{+} on the beginning of the line) sometimes do not show correct result
  \item Command \texttt{setfacl} sets it
\end{itemize}
  \begin{bashcode}
    getfacl FILE # get ACL for FILE
    setfacl -m u/g:USER/GROUP:r/w/x FILE # Add for USER/GROUP r/w/x right
    setfacl -R ... # Recursive (including subdirectories)
    setfacl -b FILE # Remove all ACL from FILE
  \end{bashcode}
\end{frame}

\begin{frame}{Set default permissions for new files}
\begin{itemize}
  \item \texttt{umask} sets implicit permissions for newly created files for user
  \item syntax is similar to \texttt{chmod}, but reverse (e.g. \texttt{027} keeps all rights for owner, for group only reading and nothing for others)
  \begin{itemize}
    \item \texttt{umask} number \textbf{removes} certain permissions
  \end{itemize}
  \item \texttt{umask 027} (or other number) is typically set in \texttt{$\sim$/.bashrc}
  \item Typically used in network environment
  \item Set with care -- new permissions will have plenty of consequences (different are typically needed for web pages, private files, shared files etc.)
  \item \texttt{umask} work recursively for all new files in user home directory -- it is not possible to set new implicit rules for particular directory
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Other permissions}
\begin{itemize}
  \item sticky bit -- new directory/file in shared directory (where everyone can write) will be deletable only by owner (typically in \texttt{/tmp})
\end{itemize}
  \begin{bashcode}
    chmod +t somedirectory
    ls -la /
    drwxrwxrwt 22 root root 800 21. led 18.20 tmp # "t" marks it
  \end{bashcode}
\begin{itemize}
  \item setgid -- application can have root permission even it was launched by normal user
\end{itemize}
  \begin{bashcode}
    chmod u+s someapplication
    ls -al /bin/passwd
    -rwsr-xr-x 1 root shadow 51200 25. zář 08.38 /usr/bin/passwd # Note "s"
  \end{bashcode}
\begin{itemize}
  \item \texttt{chattr} -- change of advanced attributes on Linux FS
  \item Usually, there is no need to modify them
\end{itemize}
  \begin{bashcode}
    chattr -RVf -+=aAcCdDeijsStTu files
    man chattr # See explanation of attributes
    lsattr # List extended attributes
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Owner and group}
\begin{itemize}
  \item Every file has a owner and group -- for finer setting of rights
  \item Group can have just one member -- the user
  \item System usually shows names of groups and users, but important are IDs: GID and UID
  \item Commands chown requires root privileges
  \item Commands chgrp commonly requires root privileges -- user has to be member of particular group to be able to change ownership to it
  \item Information about users and groups and their IDs are in \texttt{/etc/group} and \texttt{/etc/passwd}
\end{itemize}
  \begin{bashcode}
    ls -l # Shows also owner and group
    id # Display UID and GIDs of current user
    chown newowner:newgroup files # Change owner and group
    chown -R newowner files # Recursively (-R) change owner
    chgrp -R newgroup files # Recursively (-R) change group
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Root vs. ``normal'' user}
\begin{itemize}
  \item Root is administrator -- more than God -- can do anything
  \item Other users have limited permissions
  \begin{itemize}
    \item System users providing particular service (web server, database, networking service) are as restricted as possible to do the task -- security
    \item ``Human'' users don't have access to system files (at least not for modification), homes of users are separated
  \end{itemize}
\end{itemize}
Gain root privileges
  \begin{bashcode}
    su # Requires root password (stay in current directory)
    su - # Requires root password (go to /root)
    su -c "some command" # Launch one command with root permissions
    su USER # Became USER (his password is required)
    sudo -i # For trusted users, became root (asks for user's password)
            # User has to be listed in /etc/sudoers
    sudo somecommand # Launch somecommand with root's privileges
                     # Can be restricted for particular commands
  \end{bashcode}
\end{frame}

\subsection{Text}

\begin{frame}{Text and text -- differences among operating systems}
\begin{itemize}
  \item Windows and UNIX have different internal symbol for end of line (new line) -- EOL
  \begin{itemize}
    \item UNIX: LF (\texttt{\textbackslash n})
    \item Windows/DOS: CR+LF (\texttt{\textbackslash r\textbackslash n})
    \item Older Mac: CR (\texttt{\textbackslash r}) (Mac up to 9 wasn't UN*X, since OS X is)
  \end{itemize}
  \item Good text editor can open correctly any EOL, but for example execution of script written in Windows will probably fail on Linux
  \item Different systems use different encoding
  \begin{itemize}
    \item UNIX: mainly UTF-8 (unicode, universal)
    \item Windows: win-cp-125X (variants according to region)
    \item Older UNIX: ISO-8859-X (variants according to region)
    \item Other much less common types
  \end{itemize}
  \item Text editors can usually open any encoding, but auto detection commonly fails -- set it manually
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Converting the text}{Prevent bad display and weird errors when launching scripts}
  \begin{bashcode}
    unix2dos textfile # Convert text file from UNIX to Windows EOL
    unix2mac textfile # Convert text file from UNIX to old Mac EOL
    dos2unix textfile # Convert text file from Windows to UNIX EOL
    mac2unix textfile # Convert text file from old Mac to UNIX EOL
    unix2dos --help # More information about usage, include encodings
    # Converts encoding of input file (ISO-8859-2) to outfile in UTF-8
    iconv -f ISO-8859-2 -t UTF-8 infile.txt > outfile.txt
    iconv -l # List of available encodings to convert
    iconv --help # More information about usage
    recode CP1250..UTF-8 textfile # Convert encoding from CP-1250 to UTF-8
    recode ../CR-LF textfile # Convert EOL from UNIX to Windows
    recode -l # List of available encodings to convert
    recode --help # More information about usage
  \end{bashcode}
  \begin{itemize}
    \item Mac OS X mostly uses same encoding and EOL as Linux (and rest of UNIX world), so there are no problems with compatibility
    \item Launching of bash script written on Windows on Linux will probably fail (because of different EOL)
  \end{itemize}
\end{frame}

\begin{frame}[label=editors]{Importance of good text editor}{Can your text editor\ldots ?}
\begin{multicols}{2}
  \begin{itemize}
    \item Show syntax highlight
    \item Show line numbers
    \item Show space between brackets
    \item Open any encoding and EOL
    \item Fold source code
    \item Show line breaks
    \item Mark lines
    \item Open multiple files
    \item Advanced search and replace
    \item Use regular expressions
    \item Make projects
    \item Add notes
    \item Use command line
    \item Debug source code
  \end{itemize}
\end{multicols}
\begin{multicols}{4}
  \begin{itemize}
    \item \href{http://kate-editor.org/}{Kate}
    \item \href{https://www.kde.org/applications/utilities/kwrite/}{KWrite}
    \item \href{http://www.vim.org/}{Vim}
    \item \href{https://en.wikipedia.org/wiki/Emacs}{GNU Emacs}
    \item \href{http://www.geany.org/}{Geany}
    \item \href{http://bluefish.openoffice.nl/index.html}{Bluefish}
    \item \href{https://wiki.gnome.org/Apps/Gedit}{Gedit}
    \item \href{https://notepad-plus-plus.org/}{Notepad++}
    \item \href{https://www.sublimetext.com/}{Sublime}
    \item \href{https://atom.io/}{Atom}
    \item \href{http://www.nano-editor.org/}{Nano}
    \item And \href{http://texteditors.org/cgi-bin/wiki.pl?PickingATextEditor}{more}\ldots
  \end{itemize}
\end{multicols}
\end{frame}

\begin{frame}{It \textbf{is} important to select \textbf{good} text editor\ldots}
  \begin{center}
    \includegraphics[width=\textwidth-1cm]{real_programmers.png}
  \end{center}
  \begin{flushright}
    \url{https://xkcd.com/378/}
  \end{flushright}
\end{frame}

\subsection{BASH and others}

\begin{frame}{The shell}
\begin{itemize}
  \item Many names, many ways how to get it, still the same thing
  \item Fish -- friendly interactive shell -- the command line interface
  \item Terminal (console)
  \begin{itemize}
    \item Originally machine used for connection to remote server
    \item System uses old fashioned terminal for inner purposes
    \begin{itemize}
      \item From GUI available using \texttt{Ctrl+Alt+F1} to \texttt{F12}
      \item Changing terminals using \texttt{Alt+F1} to \texttt{F12}
      \item Return back to GUI using \texttt{Alt+F7}
      \item Some are used for log outputs etc.
    \end{itemize}
    \item Nowadays used ``indirectly'' with special applications (``emulators'')
  \end{itemize}
  \item Terminal emulator
  \begin{itemize}
    \item Application used to get the ``terminal'' and work in command line
    \item Every GUI has some -- Konsole, Yakuake, XTerm, Gnome Terminal, Guake, LxTerminal,~\ldots
    \item Commonly allow appearance customization -- font, colors, background, style of notifications,~\ldots
    \item Launch as many copies as you need (some allow tabs for easier work)
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{BASH and others}
\begin{itemize}
  \item Shell (sh) -- feature rich scripting programming language -- general specification, several variants
  \item So called POSIX shell -- Portable Operating System Interface -- transferable among hardware platforms (and UNIX variants)
  \item \textbf{Interpreter of our commands inserted into command line}
  \item \textbf{BASH} -- Bourne again shell
  \begin{itemize}
    \item Probably the most common shell, based on original sh, respecting original specification, adding new features
    \item We will use it
  \end{itemize}
  \item Other variants: \textbf{csh} (syntax influenced by C), \textbf{ksh} (younger, backward compatible with bash), \textbf{zsh} (extended bash), \textbf{ash} (mainly in BSD)
  \item There are subtle differences in syntax and features
  \item Language suitable for easy scripting and system tasks, not for ``big'' programming, neither for graphical applications
\end{itemize}
\end{frame}

\begin{frame}{Nice BASH features for easier work (selection)}
\begin{itemize}
  \item Arrows up and down list in the history of commands
  \item List whole history by command \texttt{history}
  \item \texttt{Ctrl+R} -- reverse search in history -- type to search last command containing typed characters
  \item \texttt{TAB} -- list command and files starting by typed characters
  \item \texttt{Home}/\texttt{End} -- go to beginning/end of the line
  \item \texttt{Ctrl+L} -- clear screen (like \texttt{clear} command)
  \item \texttt{Ctrl+Shift+C}/\texttt{V} -- copy/paste the text
  \item \texttt{Ctrl+C} -- cancel running task
  \item \texttt{Ctrl+D} -- log out (like commands \texttt{exit} or \texttt{logout})
  \item \texttt{Ctrl+U} -- move text before cursor into clipboard
  \item \texttt{Ctrl+K} -- move text after cursor into clipboard
  \item \texttt{Ctrl+left/right arrow} -- skip words
  \item \texttt{Ctrl+T} -- flip current and left character
  \item \texttt{Ctrl+X+E} -- start text editor in current directory
\end{itemize}
\end{frame}

\subsection{Variables}

\begin{frame}{Variables}
\begin{itemize}
  \item Variables contain various information (where to look for the executable programs, name of the computer, user settings,~\ldots)
  \item Can be local (within a script for some temporal purpose) or global -- available for all processes
  \item Commonly written in CAPITALS (just a costume)
  \item Popular and useful variables
  \begin{itemize}
    \item \texttt{HOME} -- location of user's home directory
    \item \texttt{HOSTNAME} -- network name of the computer
    \item \texttt{LANG} -- language settings, encoding, similarly variables\texttt{ LC\_*}
    \item \texttt{PATH} -- paths where to look for applications -- all applications have to be in \texttt{PATH} or called directly
    \item \texttt{SHELL} -- shell in use (bash or something else)
    \item \texttt{USER} -- user name
    \item And many more, commonly specific for particular server
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Work with variables}
  \begin{bashcode}
    printenv # Get all exported variables and their values
    export -p # Get all exported variables and their values
    echo $VARIABLENAME # Get value of particular variable
    echo $PATH # Get path where to look for applications
    VARIABLE='variablevalue' # Set new variable and its value
                             # Or replace existing variable by new value
    export EDITOR=/usr/bin/vim # Set new default text editor
    export PATH=$PATH:~/bin # Extend PATH -- add /home/$USER/bin
                            # Take existing PATH and add new values
                            # separated by ":"
    export GREP_OPTIONS='--color=auto' # Coloured grep
    unset VARIABLENAME # Drop variable and its value
  \end{bashcode}
\begin{itemize}
  \item Exported variables will be lost when logging off
  \item To make variables permanent, add \texttt{export} commands into \texttt{$\sim$/.profile} or \texttt{$\sim$/.bash\_profile}, or \texttt{$\sim$/.bashrc} (according to shell and its settings)
  \item ``\texttt{$\sim$}'' means home directory
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The PATH variable}
  \begin{itemize}
    \item Lists directories (separated by colon \texttt{:}) where the current shell searches for commands
    \item If some software is installed outside standard locations, the user must specify the full path (or update the \texttt{\$PATH})
    \item In case there are two commands with the same name (e.g. \texttt{/bin/somecommand} and \texttt{/usr/bin/somecommand}), the order of directories in \texttt{\$PATH} matters -- the first occurrence is used, any possible later ignored
  \end{itemize}
  \begin{bashcode}
    # See the $PATH variable
    echo $PATH # Sample output is on the next line:
    /home/$USER/bin:/usr/local/bin:/usr/bin:/bin:/opt/bin:/sbin:/usr/sbin
    # Adding new directory to $PATH
    export PATH=$PATH:/some/new/directory # Ensure to add original $PATH
    # Do not do it in the following way - it would overwrite $PATH, and
    #   there would be only the new directory (not the original content)!
    export PATH=/some/new/directory # Wrong! Old $PATH is missing!
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Reading variables from command line}
  \begin{bashcode}
    read X # We will read new variable from input (no need to use "$" here)
    10 # Type any value and press Enter
    echo $X # Get value of the variable
    10 # It works
    unset X # Destroy this variable
    # Following two commands are very similar and can lead to same result
    X=`command` # Set as variable output of command
    X=$(cat somefile) # Read into variable from file
    echo $X # X will contain content of somefile
  \end{bashcode}
\begin{itemize}
  \item This is especially useful in scripting to read input from users or from another commands
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Expressions}
  \begin{bashcode}
    # Many operands have special meaning in BASH - must be escaped
    echo `expr 1 '<' 2` # Is 1 smaller than 2? TRUE
    echo `expr 1 '>' 2` # Is 2 smaller than 1? FALSE
    echo `expr 5 '%' 2` # What remains after aritmetic division
    echo `expr 1 '&' 0` # If both arguments non-empty and not 0, then 1
    x=`expr 1 '+' 6` # Result will be in $x
    echo $x
    x=1 # Set x to 1
    y=$x+1 # Will this add 1? Why?
    echo $y # See result
    y=`expr $x + 1` # This will work - note ` and space around +
    echo $y # Result
    echo `expr length "MetaCentrum and Linux"` # Get length of chain
    # String of 10 characters starting at position 12 of the text
    echo `expr substr "MetaCentrum and Linux" 12 10`
    # Does 1st chain contain 2nd chain? Get position of first hit
    echo `expr index "GNU Linux" "Linux"` # If no overlap, return value is 0
  \end{bashcode}
\begin{itemize}
  \item \texttt{expr} works with various operands (see \texttt{man expr})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Aliases and BASH settings -- became lazy}
Alias is short cut -- instead of very long command write short alias
  \begin{bashcode}
    # Define new alias
    alias ll="ls -l"
    # Since now, instead of "ls -l" we can use just "ll"
    # To make the change above permanent, write it into ~/.profile or
    # ~/.bash_profile or ~/.bashrc and the launch
    source ~/.bashrc # to reload BASH settings
    # or "source" the file you modified
    # Popular aliases
    alias ls="ls --color=auto" # Make output of ls colored
    alias l="ls -la" # Long list (add details) with hidden files
    # Popular settings in ~/.bashrc (influencing bash, not other shells)
    test -s ~/.alias && . ~/.alias || true # Check for extra alias file
    eval "`dircolors -b`" # More colors for outputs
    HISTCONTROL='ignoreboth' # Ignore repeated entries in bash history
    HISTFILESIZE='100000' # Length of bash history
  \end{bashcode}
\end{frame}

\begin{frame}{BASH globbing and wildcards}
\begin{itemize}
  \item BASH itself doesn't recognize regular expressions -- it's wildcards have some of functions of regular expressions and can look similarly, but behave differently!
  \item \texttt{?} -- Any single character
  \item \texttt{*} -- Any number of characters
  \item \texttt{[]} -- Range or a list -- \texttt{[abcdef]} and \texttt{[a-f]} are same
  \item \texttt{[!\ldots]} -- Reverse previous case (\texttt{!}) -- any character except those listed
  \item \texttt{\{\}} -- Expansion (terms inside are separated by commas \texttt{,}) -- all possible combinations (see next slide for examples)
  \item \texttt{\textbackslash} -- Escapes following character and it doesn't have its special meaning (e.g. \texttt{\textbackslash *} means asterisk \texttt{*} and not ``any number of characters'')
  \item For details see \texttt{man 7 glob} and \texttt{man 7 regex}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Brace expansion and quotes}
  \begin{bashcode}
    echo a{p,c,d,b}e # ape ace ade abe - all combinations
    echo {a,b,c}{d,e,f} # ad ae af bd be bf cd ce cf - all combinations
    ls *.{jpg,jpeg,png} # expansion to *.jpg *.jpeg *.png, same as
    ls *.jpg *.jpeg *.png
  \end{bashcode}
\begin{itemize}
  \item Text in single quotes (\texttt{'\ldots'}) preserves the literal value of each character within the quotes
  \item Tex tin double quotes (\texttt{"\ldots"}) preserves the literal value of all characters within the quotes, with the exception of dollar (\texttt{\textdollar}), back tick (\texttt{\textasciigrave}) and back slash (\texttt{\textbackslash})
  \item A double quote may be quoted within double quotes by preceding it with a backslash
  \item Text between back ticks (\texttt{\textasciigrave\ldots\textasciigrave}) will be evaluated and then used as command or argument
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exemplar quotes and more}
  \begin{bashcode}
    a=abcdef # Set new variable
    echo $A # See variable's content
    abcdef
    echo '$A' # Single quotes preserve literal value
    $A
    echo "$A" # Double quotes preserve literal value, except $, `, \
    abcdef
    echo `$A` # Text between back ticks is evaluated and launched
    abcdef: command not found # There is no command "abcdef"...
    WORKDIR=`pwd` && echo $WORKDIR # Common use of `...` and $
    echo "Hi, dear $USER" # Compare this and following command...
    echo 'Hi, dear $USER' # Single quotes do not evaluate variables
  \end{bashcode}
\begin{itemize}
  \item \alert{\texttt{\textdollar}} marks variables
  \item \alert{\texttt{\textbackslash}} escapes following character -- it will not have its special meaning (space to separate arguments,~\ldots)
  \item \alert{\texttt{*}} replaces any characters (\texttt{ls a*} lists all files starting with ``a'')
  \item \alert{\texttt{?}} replaces one single character
\end{itemize}
\end{frame}

\begin{frame}[fragile, label=links]{Links}
\begin{itemize}
  \item Soft links -- like links on the web -- short-cut to another place: \texttt{ln -s source target}
  \begin{itemize}
    \item When we delete link, nothing happens, when target, non-working link remains
  \end{itemize}
\end{itemize}
  \begin{bashcode}
    ls -l bin/cinema5
    lrwxrwxrwx 1 vojta users 42 5. dub 2014 cinema5 -> # "l" marks link
      /home/vojta/bin/cinema5-0.2.1-beta/cinema5* # "->" points to target
  \end{bashcode}
\begin{itemize}
  \item Hard links -- only second name for file already presented on the disk (available only for files): \texttt{ln source target}
\end{itemize}
  \begin{bashcode}
    ln .bashrc .bashrcX
    ls -l .bash* # Numbers in first column show links pointing to it
                 # For directories - number of items, for files = 1
    -rw------- 1 vojta users 27298 21. led 16.43 .bash_history # One link
    -rw-r--r-- 2 vojta users  2707 29. lis 16.21 .bashrc # Same file as below
    -rw-r--r-- 2 vojta users  2707 29. lis 16.21 .bashrcX # Two links
  \end{bashcode}
\end{frame}

\begin{frame}{Places to store BASH settings}
  \begin{itemize}
    \item \texttt{$\sim$/.bashrc} -- File is loaded each time user creates new session (typically opens new terminal window)
    \item \texttt{$\sim$/.bash\_profile} -- Used specifically (not in every system) when user is using remote connection (SSH)
    \item \texttt{/etc/bash.bashrc} -- System wide BASH settings -- can be overridden by user's configuration
    \item \texttt{$\sim$/.profile} -- Settings loaded when user logs-in (mainly for language settings), sometimes used by remote connections
    \item \texttt{/etc/profile} -- System wide profile file -- can be overridden by user's configuration
    \item \alert{Note:} BASH scripts are non-interactive shells -- they do not read settings above -- there are no aliases,~\ldots{ }but they inherit some settings (PATH, language,~\ldots)
  \end{itemize}
\end{frame}

\section{Command line}

\begin{frame}{Launching commands and scripts}
\begin{itemize}
  \item Parameters of commands are separated by space and preceded by one or two minus(es)
  \item Parameter \texttt{-h} or \texttt{--help} usually gives help for particular command
  \item Getting help with \texttt{man} command
  \begin{itemize}
    \item \texttt{man somecommand}
    \item Arrows to list up and down, \texttt{q} to quit
    \item Type \texttt{/} and type text and hit Enter to search -- next hit by \texttt{n}, quit search by ESC (twice)
    \item Command \texttt{info} more advanced -- type \texttt{?} for help
  \end{itemize}
  \item Parameters can be combined, order doesn't matter (same variants: \texttt{ls -la}; \texttt{ls -al}; \texttt{ls -a -l}; \texttt{ls -l -a})
  \item ``Long'' parameters (\texttt{{-}-XXX}) must stay separated
  \item Commands must be in PATH -- actual directory isn't in PATH
  \begin{itemize}
    \item If the script is is current directory, use \texttt{./script.sh} or full path
  \end{itemize}
  \item Custom scripts must have execute permission (\texttt{chmod +x script.sh})
\end{itemize}
\end{frame}

\begin{frame}{Screen}{Split terminal or keep task running after logging off}
\begin{itemize}
  \item When you log off or network connection is broken, running tasks for particular terminal usually crash
  \item Sometimes number of connections is limited
  \item \texttt{screen} is solution -- virtual terminals
  \item Launch \texttt{screen} to start new screen terminal, read some info, confirm by \textbf{Space key} or \textbf{Enter}
  \item To detach from the screen press \texttt{Ctrl+A, D} -- screen is still running in background -- you can even log off
  \item To return back to running screen use \texttt{screen -r} -- if only one screen is running, you get back to it
  \item If more screens are running, use \texttt{screen -r 1234} (the number is seen from \texttt{screen -r})
  \item To cancel running screen press \texttt{Ctrl+D} (or type \texttt{exit} or \texttt{logout})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Automated launching of tasks}
\begin{itemize}
  \item \texttt{at} can run command at certain time (atd daemon must be running)
\end{itemize}
  \begin{bashcode}
    systemctl status/start/stop atd.service # Check/start/stop if atd runs
    at HHMM # Run commands at certain time check "man at" for time settings
    at> command1 # Add as many commands as you wish (separate by Enter)
    # When done, press Ctrl+D to cancel giving commands to at
    at HHMM <<< 'cat somescript.sh' # Run script at certain time
  \end{bashcode}
\begin{itemize}
  \item \texttt{cron} runs tasks repeatedly (cron daemon must be running)
\end{itemize}
  \begin{bashcode}
    systemctl status/start/stop cron.service # Check/start/stop if cron runs
    crontab -l # List cron tasks
    crontab -e # Edit cron tasks:
    # Minute, Hour, Day in month, Month, Day in week, Command (absolute path)
    # 0-59    0-23  1-31          1-12   0-6 starting with Sunday (WTF?)
      *       *     *             *      *            /usr/bin/command
      10      22    1             *      *        # 1st day in month, 23:11
      0       */3   *             *      *        # Every 3 hours
    # root can copy scripts into directories /etc/cron.*/
  \end{bashcode}
\end{frame}

\subsection{Chaining}

\begin{frame}{Chaining commands}
\begin{itemize}
  \item \alert{\texttt{\&}} -- command will be launched in background, terminal is available for next typing: \texttt{firefox \&} (when launching graphical application, hit \textbf{Enter} afterward if there is no active command line prompt)
  \item \alert{\texttt{\&\&}} -- second command is launched only when first command exits without error (exits with status \texttt{0}): \texttt{mkdir NewDir \&\& cd NewDir}
  \item \alert{\texttt{;}} -- second command is launched regardless exit status of the first one: \texttt{kshfskcbd; hostname}
  \item \alert{\texttt{\textbraceleft\ldots\textbraceright}} -- commands within curl brackets are launched as one block
  \item \alert{\texttt{||}} -- second command is launched when first command fails (has non zero exit status):\\\texttt{cd newdir || \textbraceleft~mkdir newdir \&\& cd newdir; \textbraceright}
  \item Behavior in shells other than bash might be little bit different
  \item \alert{\texttt{|}} -- pipe -- redirects standard output of one command into standard input of second command: \texttt{ps aux | sort}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Standard input and output and redirects}
\begin{itemize}
  \item Standard input (\texttt{stdin}) is standard place where software takes input (keyboard and terminal) and writes results to standard output (\texttt{stdout}) -- typically monitor
  \item Standard error output (\texttt{stderr}) is target of error messages -- typically also monitor (but can be log file or so)
  \item \alert{\texttt{\textgreater}} redirects output into new place (file, device, another command,~\ldots)
\end{itemize}
  \begin{bashcode}
    cat /etc/group # Print whole file /etc/group
    grep users /etc/group > users # Extract from /etc/group lines containing
                                  # "users" and write output into new file
    cat users # See result
  \end{bashcode}
\begin{itemize}
  \item \alert{\texttt{\textgreater\textgreater}} adds output to the end of the file (\texttt{\textgreater} rewrites target file)
\end{itemize}
  \begin{bashcode}
    grep root /etc/group >> users # Add new information into existing file
    cat users # See result
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Redirects of standard input and output}
  \begin{bashcode}
    # Write directory content into text file
    # If file directory_listing.txt exists, will be overwritten
    ls -la > directory_listing.txt
    # If file directory_listing.txt exists, new content will be added to
    # the end
    ls -la >> directory_listing.txt
  \end{bashcode}
\end{frame}

\begin{frame}[fragile, label=pipe]{Redirects and pipes}
  \begin{bashcode}
    # Add error output to the end of standard output file
    command >> outputfile 2>&1
    # Add error output to the error log text file
    command >> outputfile 2>error.log
  \end{bashcode}
\begin{itemize}
  \item \texttt{/dev/null} -- ``black hole'' -- discards everything (don't care about errors?): \texttt{command 2\textgreater~/dev/null}
  \item \texttt{/dev/stdin} -- standard input (in case application reads files, not from standard input): \texttt{echo "Žluťoučký kůň" | iconv -f utf-8 -t cp1250 /dev/stdin}
  \item \texttt{/dev/stdout} -- standard output (we wish to see errors which would be discarded otherwise): \texttt{command 2\textgreater~/dev/stdout}
  \item \texttt{/dev/stderr} -- standard error output (right place to send errors to): \texttt{echo "error" > /dev/stderr}
\end{itemize}
\end{frame}

\subsection{Information and management}

\begin{frame}[fragile]{Which system are we using?}
  \begin{bashcode}
    uname -a # Information about Linux kernel (version, ...)
    lsb_release -a # Information about Linux distribution release
    cat /etc/os-release # Similar to above command
    lscpu # Information about CPU
    cat /proc/cpuinfo # Raw list of information about CPU
    lsusb # List of devices on USB
    lspci # List of PCI devices (graphic card, network card, ...)
    lshw # Complete list of hardware
    lshw -C memory # Information about RAM
    hwinfo # Complete list of hardware
    hwinfo --network # Information about network devices
    free -h # Available memory (RAM) and swap, -h for nice units
    df -h # Free space on disk partitions, -h for nice units
    lsmod # List loaded kernel modules
    uptime # How long is the system running, number of users, average load
    date # Date and time - plenty of options for formatting
    mount | column -t # Information about mounted file systems
    findmnt # Display mounted devices in tree structure
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Processes -- every running program has its own process}
  \begin{bashcode}
    htop # Nice listing of processes (better version of top), quit using "q"
    pstree # See running processes with child processes, recursively
    pgrep application # Return PID (process ID) of application
    ps # processes related to actual terminal
    ps x # All user's processes
    ps aux # All processes
    # kill (terminate) process by name or process ID (PID)
    ps aux | grep geany # Find which PID has application to terminate
    # This is the application - its PID we need
    vojta 14639 9.3 0.8 2828512 134816 ?   Sl 16:12 0:01 /usr/bin/geany
    # This is previous "ps aux | grep geany" command (last column)
    vojta 14769 0.0 0.0   9440  1628 pts/0 S+ 16:12 0:00 grep geany
    kill -SIGTERM 14639 # SIGTERM is "nice" termination, SIGKILL "brutal"
    killall -SIGTERM geany # Select by name (more processes with same name)
    # nice - how much resources will task use: from -20 (high priority - not
    # "nice" process) to +19 (low priority - very "nice" process), default 0
    nice -n 7 hard_task.sh # set priority 7 for newly launched task
    renice 15 16302 # Change priority of PID 16302 to 15
    sudo renice 15 16302 -u USER # Change priority of USER's process
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Users}
  \begin{bashcode}
    whoami # What is my user name
    id # Information about current user (user ID and group IDs)
    who # Who is logged in
    w # Who is logged in, more information
    users # Plain list of currently logged users
    finger # Information about users on current terminals
    last # Last logged-in users
    passwd # Change password
    passwd USER # Change USER's password
    groups # List your groups
    # Following commands to manage users and groups do not have to work
    # on all systems - depends on authentication methods used
    useradd newuser # Add new user
    usermod --help # Modify user, see possible modifications
    userdel user # Delete user
    groupadd newgroup # Add new group
    groupmod --help # Modify group, see possible modifications
    groupdel group # Delete group
  \end{bashcode}
\end{frame}

\subsection{Directories}

\begin{frame}[fragile]{Directories}
  \begin{bashcode}
    pwd # Print working directory - where we are right now
    cd # Change directory (just "cd" or "cd ~" goes to home directory)
    cd .. # One directory up; cd ../..; cd ../../another/directory/
    cd relative/path/from/current/position # Go to selected directory
    cd /absolute/path/from/root # Absolute path starts by "/"
    tree # Tree like hierarchy of files and directories
    tree -d # List only directories; see tree --help
    tree -L 2 # Only up to second level; combine: tree -d -L 3
    du -sh # Disk usage by current directory, -s for sum, -h for nice units
    mkdir NewDirectory # Make directory
    rmdir DirectoryToRemove # Remove empty directory
    ls # List directory content
       # Try parameters -l, -a, -1, -F, -h (with -l or -s), --help
    rm -r # Recursive delete - remove also non-empty directories
    mv from to # Move files/directories (also for renaming)
    cp from to # Copy, -r (recursive, including subdirectories)
               # -a (keeps all attributes), -v (verbose)
    file somefile # Information about questioned file (what it is, ...)
    xdg-open somefile # Open file by graphical application as in GUI
  \end{bashcode}
\end{frame}

\begin{frame}{Midnight Commander}
\begin{multicols}{2}
\begin{itemize}
  \item \texttt{mc} to launch MC
  \item Move, copy, delete, files/directories, connect to SSH/(S)FTP,~\ldots
  \item Can be used with mouse
  \item Edit text files (\texttt{F4})
  \item \texttt{F2} for quick menu
  \item \texttt{F9} for top menu with many functions
  \item And much more\ldots
  \item Not possible to live without it :-)
\end{itemize}
\includegraphics[height=6.5cm]{mc.png}
\end{multicols}
\end{frame}

\subsection{Archives}

\begin{frame}{Compressing files into archives}
\begin{center}
\begin{tabular}{llll}
\textbf{Archive} & \textbf{Compressing command}\\
*.tar & tar cvf archive.tar file1 file2\\
*.tar.gz\alert{/}*.tgz & tar czvf archive.tar.gz\alert{/}.tgz file1 file2\\
*.tar.bz\alert{/}*.tbz\alert{/}*.tar.bz2 & tar cjvf archive.tar.bz\alert{/}.tbz\alert{/}.tar.bz2 file1 file2\\
*.tar.xz & tar cvf - file1 file2 | lzma > archive.tar.xz\\
*.gz & gzip file\\
*.bz2 & bzip2 file\\
*.xz & lzma file\\
*.zip & zip -r archive.zip file1 file2\\
*.rar & rar a archive.rar file1 file2\\
\end{tabular}
\end{center}
\begin{itemize}
  \item \texttt{gzip}, \texttt{bzip2} and \texttt{lzma} are able to pack only one file -- use them together with \texttt{tar} to pack multiple files
  \item \texttt{gzip}, \texttt{bzip2} and \texttt{lzma} when used \textbf{without} \texttt{tar} \alert{move} file into archive
  \item \texttt{lzma} has excellent compression, but sometimes is very slow
\end{itemize}
\end{frame}

\begin{frame}{Compressing and decompressing archives}
  \begin{center}
    \begin{tabular}{llll}
      \textbf{Archive} & \textbf{Decompressing command}\\
      *.tar & tar xvf archive.tar\\
      *.tar.gz\alert{/}*.tgz & tar xzvf archive.tar.gz\alert{/}.tgz\\
      *.tar.bz\alert{/}*.tbz\alert{/}*.tar.bz2 & tar xjvf archive.tar.bz\alert{/}.tbz\alert{/}.tar.bz2\\
      *.tar.xz & lzcat archive.tar.xz | tar xvf -\\
      *.gz & gunzip archive.gz\\
      *.bz2 & bunzip2 archive.bz2\\
      *.xz & unlzma archive.xz\\
      *.zip & unzip archive.zip\\
      *.rar & unrar x archive.rar\\
    \end{tabular}
  \end{center}
  \includegraphics[height=2cm]{tar.png}
  \hfill
  \url{https://xkcd.com/1168/}
\end{frame}

\subsection{Searching}

\begin{frame}[fragile]{Looking for files}
  \begin{bashcode}
    locate somename # Searches for files/directories in local database
    updatedb # Must be regularly launched to get "locate" to work
    which # Full path to application (shell command)
    whereis # Path to source code, executable and man pages for the command
    # Test if executable command exists (good for scripts)
    # If "Application" is missing, script ends with error
    command -v Application >/dev/null 2>&1 || { echo >&2 "Application is
      required but not installed. Aborting." }
    command -v find # Behaves like which, but reliable in scripts
    type Application >/dev/null 2>&1 || { echo >&2 "Application is
      required but not installed. Aborting."; }
    hash Application 2>/dev/null || { echo >&2 "Application is required
      but not installed. Aborting."; }
    exit 1; # It can be added before the end of the bracket to send
            # term signal 1 - for better handling of various errors
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Find}
  \begin{bashcode}
    find # The most powerful searching tool, many parameters (man find):
    find <where> -type d/f -name XXX -print
    find photos/ -name *.jpg -exec mogrify -resize 1000x1000 '{}' \;
  \end{bashcode}
  \begin{itemize}
    \item First \texttt{find}'s parameter is location to search -- absolute or relative, ``\texttt{.}'' means current directory (the only compulsory parameter)
    \item \texttt{-type} for only directories or only files (without this parameter, files as well as directories are looked for)
    \item \texttt{-name} supports wildcarts (\texttt{*}, \texttt{?} and \texttt{[\ldots]})
    \item \texttt{-print} is default action -- prints list of results
    \item \texttt{-exec} runs some command with results (e.g. find all images and resize them)
    \begin{itemize}
      \item All following arguments are argument of the command until ``\texttt{;}'' is encountered
      \item \texttt{\{\}} is replaced by the current file name being processed
      \item Those constructs might require protection by escape (``\textbackslash'') or quotes not to be expanded by shell
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Network}

\begin{frame}{Network protocols}
  \begin{itemize}
    \item SSH -- secure shell -- command-line connection to remote server to work there (port 22)
    \item Telnet -- old deprecated insecure version of SSH, never ever use it (port 23)
    \item FTP -- file transfer protocol -- outdated, no encryption (port 21)
    \item FTPS -- FTP with added connection encryption for higher security (port 21)
    \item SFTP -- FTP over SSH -- common, secure (port 22)
    \item SCP -- secure copy -- uses SSH, but has restricted possibilities, common, secure (port 22)
    \item NFS -- network file share/server -- very common in UNIX world, commonly used to permanently connect to network server, share directories, etc. (port 2049)
    \item webDAV -- file transfer over web (using WWW server) -- not so common, but good (port 80 or 443 -- same as WWW)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Connect to SSH with key}
  \begin{itemize}
    \item No need to remember password for every server\ldots
  \end{itemize}
  \begin{bashcode}
    # Create the key
    ssh-keygen -t rsa -b 4096 # Good security, portable
    # ECC gives better security, but not all servers/applications support it
    ssh-keygen -t ecdsa -b 521 # Higher security
    ssh-keygen -t ed25519 # Same security as ecdsa, higher performance
    # Empty (no) passphrase will connect to server without password
    # Copy public key to remote server (private key must be kept locally)
    ssh-copy-id user@remote.server.cz # or
    cat ~/.ssh/XXX.pub | ssh user@remote.server.cz \
      "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
    # Now, public key is on the server and private key in local computer is
    # unlocking the connection
    # Unlock the key (no need in some distributions or if there is no
    # passphrase) - must be done only once per user session
    ssh-add
    # Connect as usually
    ssh user@remote.server.cz
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Basic network information and testing}
  \begin{bashcode}
    hostname # Get name of the computer
    ping web.natur.cuni.cz # Ping host. Is it alive? Cancel by Ctrl+C
    traceroute www.metacentrum.cz # Get route to the host
    mtr hostname # Combines ping and traceroute, quit with "q"
    ip a s # Information about all network devices (MAC, IP address, ...)
    ifconfig -a # Older version of above command
    iwconfig # List of network interfaces
    ip r # Show routes
    nc -vz web.natur.cuni.cz 22 # Does SSH work on the host?
      # verbose (-v), scan (-z), host, port number (22 for SSH, can be any)
    man nc # See for more information; "nc" is alias for "netcat"
    netstat -atn # Information about all network connections
    netstat -ntplu # Show open TCP/UDP ports
    netstat -anp # Show active connections
    netstat -h # See for explanation of 3 above examples
    nmap -r someserver # Scan someserver for opened ports
                       # If using at faculty, firewall disconnects you!
    nmap botany.natur.cuni.cz --script ssh-hostkey # See SSH key
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Transferring files from/to remote server}
  \label{transfers}
  \begin{itemize}
    \item \texttt{curlftpfs} allows mount FTP as local directory, but FTP is outdated, insecure and not constructed to that usage\ldots
  \end{itemize}
  \begin{bashcode}
    wget http://some.address.cz/internet # Download file(s) from Internet
    wget --help # -r for recursive download (whole web), -k to convert links
    # curl is predecessor of wget, without parameter "-o" it prints remote
    # content to standard output (typically screen)
    curl http://some.server.cz/some/files -o localfilename
    # Copy files (-r for recursive) over SSH from local computer to
    # remote server or vice versa (just flip arguments)
    scp -r localfiles remoteuser@remote.server.cz:/remote/path/
    scp -r remoteuser@remote.server.cz:/remote/files /local/directory/
    # scp behaves like cp, but works over SSH
  \end{bashcode}
  \begin{itemize}
    \item \texttt{rsync} is synchronization tool (commonly used for backups) able to co connect to remote server (next slide)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Synchronization with rsync}
  \begin{itemize}
    \item \texttt{rsync} has huge amount of possibilities (see \texttt{man rsync} or \texttt{rsync -h})
    \item Works locally as well as over network
    \item It transmits only changes -- very efficient
    \item Suitable for local as well as network backup
    \item Network address for rsync is written in same way as for \texttt{scp}
    \item \texttt{--delete} delete in target location files which are not in source location any more
    \item \texttt{--progress} show progress percentage for every file
    \item \texttt{--exclude=*.jpg} skip JPG files
    \item For incremental backups use \texttt{duplicity}
  \end{itemize}
  \begin{bashcode}
    rsync -arv somedirectory otherplace # All attributes, recursive, verbose
    rsync -arv localdirectory user@remote.server.cz:/remote/directory/
    rsync -arv user@remote.server.cz:/remote/data local/directory/
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Connecting file systems on remote servers}
  \begin{itemize}
    \item Mounting and unmounting of remote servers require root privileges
    \item Target mount point must exist before mounting
    \item Servers can be accessed by IP address or hostname
  \end{itemize}
  \begin{bashcode}
    # Mount Windows server
    mount.cifs //windows.server.cz/Some/Directory /mnt/win -o \
      credentials=/path/to/password.file,uid=USER,gid=GROUP
    # "password.file" contains login credentials to Windows server:
    username=user.name
    password=TopSecretPassword1
    domain=DOMAINNAME
    man mount.cifs # See for other connection options
    # Mounting remote server over SSH (sshfs package must be installed)
    sshfs user@vyuka.natur.cuni.cz:/some/dir /local/mount/point
    # Mount NFS share (NFS is common protocol in UNIX world)
    mount -t nfs some.server.cz:/shared/directory /local/directory
    # Mount webDAV folder (requires package davfs2 to be installed)
    mount -t davfs https://owncloud.cesnet.cz/directory /local/directory
  \end{bashcode}
\end{frame}

\subsection{Parallelisation}

\begin{frame}{Parallelisation with GNU Parallel}
\begin{itemize}
  \item \href{https://www.gnu.org/software/parallel/}{GNU Parallel} can distribute task among CPU threads of one computer, or even among different computers in network
  \item It is not effective for short/small tasks
  \item Important operands (for more see \texttt{man parallel})
  \begin{itemize}
    \item \texttt{\{\}} -- input line -- whole line read from input source (typically standard input)
    \item \texttt{\{.\}} -- input line without extension
    \item \texttt{\{/\}} -- base name of input line -- only file name (without path)
    \item \texttt{\{//\}} -- dirname from input line (filename is removed)
    \item \texttt{\{/.\}} -- base name of input line without extension
    \item \texttt{:::} -- use arguments from command line instead of stdin (::: is placed after the command and before the argument)
    \item \texttt{::::} -- read from argument files
    \item \texttt{-j} -- number of jobs -- if not provide, \texttt{parallel} will use all available CPU threads
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{GNU Parallel examples I}
  \begin{bashcode}
    # Convert all images from JPG to PNG
    ls -1 *.jpg | parallel --bar convert '{}' '{.}.png'
    # Resize all images ("\" marks that command continue on next line)
    find . -name '*.jpg' -print | parallel convert -resize 1000x1000 \
      -quality 75 '{}' '{.}-small.jpg' # or
    parallel convert -resize 1000x1000 '{}' '{.}-small.jpg' ::: *.jpg
    # Find WORD in huge text file (named "longfile" here) - this works
    # but it is not possible to get line number (file is red in blocks)
    parallel --pipe --block 10M -- grep --color=always WORD < longfile
    # Same as above but add line numbers according to original file
    nl longfile | parallel -k --pipe --block 20M -- grep WORD
    # When needed to get phrase or regular expression (use parameter
    # "-q" for escaping of shell special characters or extra quotes):
    # "--" stops reading parameters for parallel
    nl longfile | parallel -qk --pipe --block 20M -- grep "WORD TEXT" # or
    nl longfile | parallel -k --pipe --block 20M -- grep '"WORD TEXT"'
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{GNU Parallel examples II}
  \begin{bashcode}
    # Run in parallel commands from command list file (list of commands)
    parallel < command_list.txt # (each command on one line) or
    parallel :::: command_list.txt
    # Add same text to the end of multiple files
    ls -1 *.txt | parallel 'cat block_to_be_added.txt >> {}'
    # Replace particular text in multiple files with sed and GNU Parallel
    ls -1 *.txt | parallel 'sed -i "s/XXX/YYY/g" {}'
    # Launch MrBayes for multiple nexus files and create log file with
    # starting and ending date and time
    ls -1 *.nexus | parallel 'echo Start > {}.log && date >> {}.log && \
      mrbayes {} | tee -a {}.log && echo End: >> {}.log && date >> {}.log'
    # tee (-a for append to existing file) records output of MrBayes
    command | tee record.txt # tee will record whole output of command
    tee record.txt | command # tee will record user input
    # If software reads commands from user, we can reuse record next time:
    command < record.txt # Empty lines are interpreted as Enter key
                         # Each line is used whenever command waits for new
                         # input (instead of user typing, record.txt is used)
  \end{bashcode}
\end{frame}

\subsection{Other}

\begin{frame}[fragile]{Removable media}
  \begin{itemize}
    \item Mounting and unmounting of devices require root privileges
    \item In Linux, physical disks are named from \texttt{sda} to \texttt{sdz}, each disk has partitions (at least one) numbered from \texttt{1}, e.g. \texttt{sda1}, \texttt{sda2}, \texttt{sdb1},~\ldots{ }-- all are accessible in \texttt{/dev} directory (\texttt{/dev/sdc3},~\ldots)
    \item Target mount point must exist before mounting
  \end{itemize}
  \begin{bashcode}
    eject # Open CD/DVD drive
    mount # Which FS (disk partitions) are mounted
    findmnt # See mounted devices in tree-like structure
    # mount usually recognize FS of mounted device, if not, us -t FS_type
    mount /dev/sdXY /mount/directory # Mount disk sdXY to /mount/directory
    umount /dev/sdXY # Unmount disk sdXY
    umount /mount/directory # Unmount disk from /mount/directory
    dmesg | grep sd | tail # Get information about recently plugged media
    mkdir /mnt/iso # Directory must exist prior mounting into it
    # Mount CD/DVD ISO image file into directory /mnt/iso
    mount -t iso9660 -o loop file.iso /mnt/iso # See CD/DVD image content
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Other commands}
  \begin{bashcode}
    touch filename # Creates empty text file
    echo # Write empty line of text
    echo $USER # Write value of variable $USER
    echo "Some text" # Write text in quotes
    # dd produces physical copy of whole device - including empty space
    dd if=/dev/sdXY of=image.iso # Backups disk sdXY to imago.iso
    dd if=image.iso of=/dev/sdXY # Used to write image of Linux live
                                 # media to USB flash disk
    apropos keyword # Searches for command descriptions containing keyword
    dmesg # Recent entries in main system log - filter with grep, tail, ...
    lnav # Comfortably browse recent logs, quit by "q"
  \end{bashcode}
\end{frame}

\section{Text}

\subsection{Reading}

\begin{frame}[fragile]{Read text file}
  \begin{bashcode}
    cat # Read or join files (-n adds line numbers, -v prints non-printable
        # characters like EOL)
    cat textfile # Print content of text file
    cat textfile1 >> textfile2 # Add textfile1 to the end of textfile2
    nl textfile # Like cat -n, prints textfile with line numbers
    tac textfile # Like cat, but prints lines in reverse order
    more textfile # When textfile is long, prints screen by screen (space
                  # for next screen, q to quit)
    less textfile # Better version of more - you can scroll up and down by
                  # PgUp, PgDown, arrows, searching by / (type searched
                  # string, hit Enter, n for next, twice ESC to quit),
                  # q to quit viewing
    most textfile # Better version of less
    fmt textfile # Basic formatting of text - joining of commented lines,
                 # line breaks to break too long lines, ...
    fmt textfile > formatted_file # Save output of fmt into new file
    wc textfile # lines, words and bytes in text file
                # wc -l for only lines, -m for characters, -w for words
  \end{bashcode}
\end{frame}

\subsection{Extractions}

\begin{frame}[fragile]{Get part of text file}
  \begin{bashcode}
    head -n N textfile # Print first N lines from textfile
    tail -n N textfile # Print last N lines from textfile
    head -n-N textfile # Print textfile without last N lines
    tail -n+N textfile # Print textfile from Nth line to the end
    # Split text file on selected pattern - creates new files xxXY
    csplit textfile '/pattern/' '{*}' # pattern itself is inside '/___/'
    # Pattern can be regular expression - set it carefully
    # {*} says to repeat operation as many times as possible
    grep -parameters pattern textfile # Write lines containing pattern
    grep user /etc/passwd # Write all lines in passwd containing user
    cat /etc/passwd | grep user # Same as above
    grep -v user /etc/passwd # Write all lines in passwd NOT containing user
    grep -c user /etc/passwd # get number of lines in passwd containing user
    grep -i USER /etc/passwd # -i isn't case sensitive
    grep -q ... # quiet - no output - good for testing in scripts
    grep -ls user /etc/* # -l print files with pattern, -s suppresse errors
    grep "longer text" textfile # Extract whole phrase
  \end{bashcode}
Grep supports regular expressions, slide \ref{regexp}.
\end{frame}

\begin{frame}[fragile]{Get a column -- cut, awk}
  \begin{bashcode}
    cut column/delimiter+field textfile
    cut -c 1 /etc/group # Get first character
    cut -c 1-5 /etc/group # Get character 1-5
    cut -c 4- /etc/group # Get character 4 and more
    cut -c 2,5,7 /etc/group # Get characters 2, 5 and 7
    cut -d ':' -f 1 /etc/group # Select 1st field separated by ":"
    cut -d ':' -f 2-4 /etc/group # Select fields 2-4 separated by ":"
    cut -d ':' -f 1,3 /etc/group # Select fields 1 and 3 separated by ":"
    awk 'regexp { commands parameters }' file
    awk '{print $NF}' textfile # Select last column (separated by tab)
    awk '{print $2}' textfile # Select 2nd column (separated by tab)
    awk '{print $3, $2}' textfile # Print columns 3 and 2 (in this order)
    awk -F ' ' '{print $4, $1}' textfile # Print columns 4 and 1
                                         # separated by " " (space)
    ls -l | awk '/^d/ { print $8 "\t" $3 }' # Separate columns by TAB
               # /^d/ for lines starting with "d" (only directories)
  \end{bashcode}
  \begin{itemize}
    \item For regular expressions, see slide \ref{regexp}
    \item BASH can not select column according to its name (Perl can do that)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{More about AWK}
  \begin{itemize}
    \item AWK is scripting language for text manipulations
    \item Only basic examples here\ldots
  \end{itemize}
  \begin{bashcode}
    # Print on each line ">", field 1, make new line (\n) and print field 2
    awk '{print ">"$1"\n"$2}' textfile
    # Print field 1, TAB (\t), length of field 2, TAB and field 2
    awk '{print $1"\t"length($2)"\t"$2}' textfile
    # If field 1=0, print whole line
    awk '{if($1==1){print $0}}' textfile
    # Field 1 is numeric (less then 5 digits) - add leading zeroes
    awk '{printf "%05d\n", $1;}' textfile
    # As above, but add leading zeroes to field 1 and print whole line
    awk '{$1=sprintf("%05d", $1); print $0}' textfile
    # Field 1 is numeric, select lines where field 1 is higher than 100
    awk '$1>100' textfile
    # Print field 4 (fields are separated by "_" or TAB)
    awk -F '[_\t]' '{print $4}'
  \end{bashcode}
\end{frame}

\subsection{Manipulations}

\begin{frame}[fragile]{Sorting}
  \begin{bashcode}
    sort textfile # Sort a text file
    sort -d textfile # Take into account only spaces and alphanumerical
                     # characters (ignore any other characters)
    sort -r textfile # Reverse order
    sort -f textfile # Ignore character case (not case sensitive)
    sort -m textfile1 textfile2 # Merge already sorted text files
    sort -u textfile # Print only first of multiple entries
    sort -b textfile # Ignore leading blanks (space on beginning of line)
    # Sorting is influenced by locale setting (e.g. Czech ``ch'')
    # To force use of English locale use
    LC_ALL=C sort ... # Set for this command language variable to English
    uniq textfile # Filters following identical lines - only unique
                  # are printed (to get unique lines from whole file,
                  # sort it first)
    uniq -c textfile # Add number of occurrences before each line
    uniq -d textfile # Print only repeated lines
    uniq -i textfile # Ignore case (not case sensitive)
    uniq -s N textfile # Skip first N characters
    uniq -u textfile # Print only not-repeated lines
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Replacements -- tr}
  \begin{itemize}
    \item \texttt{tr} replaces or deletes characters from standard input and writes result to standard output -- use pipes and/or redirects:
  \end{itemize}
  \begin{bashcode}
    # Replace space by TAB in inputtextfile, save result as outputtextfile
    cat inputtextfile | tr " " "\t" > outputtextfile
    # Delete "text" from each line and print it to standard output (screen)
    cat inputtextfile | tr -d "text"
    # Replace every occurrence of A, B, C or D by a new line (\n)
    cat inputtextfile | tr "[ABCD]" "\n" > outputtextfile
    tr --help # See possible replacement patterns
    # Replace capital letters by small ones
    tr "[A-Z]" "[a-z]" < inputtextfile > outputtextfile
    # Alternative (easier reading) of previous command:
    cat inputtextfile | tr "[A-Z]" "[a-z]" > outputtextfile
    # Alternative solution using sed (next slide)
    sed 's/[A-Z]/\L&/g' inputtextfile > outputtextfile # Vice versa:
    sed 's/[a-z]/\U&/g' inputtextfile > outputtextfile
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Replacements -- sed I}
  \begin{bashcode}
    sed 's/FindToReplace/Replace/modificator' textfile > newtextfile
    # Search and replace ("s") all occurrences ("g") of "find" by "replace"
    sed 's/find/replace/g' textfile
    # Replace third occurrence of pattern on every line
    sed 's/pattern/ToReplace/3'
    # To work only on particular line, place number or range (e.g. 1,7)
    # right before "s" (sed '1,7s/...')
    sed '1~2n;s/F/R/g' # Work on every second line, starting by line 1
    sed -n -e '2~10p' # Print every 10th line, starting with line 2
    seq 1 100 | sed -n -e '2~10p' # Example of above pattern
    # Replace first TAB (\t) on each line by new line (\n)
    sed 's/\t/\n/' textfile
    sed 's/find/replace/g' somedirectory/* # Work on all files in directory
    sed -i ... # Modify processed file - otherwise output is printed on
               # standard output (screen - can be piped into text file, ...)
  \end{bashcode}
  \begin{itemize}
    \item \texttt{sed} supports regular expressions, see slide \ref{regexp} (same as in \texttt{grep} and \texttt{vim}), with parameter \texttt{-e} can use extended regular expressions (Do not confuse!)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Replacements -- sed II}
  \begin{bashcode}
    # Groups to remember work in same way in sed, grep as well as vim
    \(ToRemember\) # Remember expression in brackets
    \Number # Use remembered expression (numbered from one)
    # Take output of ls -l and replace # "users" by "users-RULEZZZ"
    ls -l | sed 's/\(users\)/\1-RULEZZZ/g'
    # Add "size:TAB" before file size column (we suppose it has 3-8 digits)
    ls -l | sed 's/\([0-9]\{3,8\}\)/size:\t\1/g'
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Comparisons}
  \begin{bashcode}
    # Compare two sorted columns
    comm textfile1 textfile2
      # 1st column - lines only in textfile1
      # 2nd column - lines only in textfile2
      # 3rd column - lines in both files
    comm -2 textfile1 textfile2 # Don't show 2nd column (similarly -1, -3)
    # Show differences between text files
    diff textfile1 textfile2
      # First number shows line(s) in 1st file, then if add/delete/change
      # and last number shows line(s) in the second file, <> show direction
    diff -e textfile1 textfile2 # More simple output
    diff -c textfile1 textfile2 # Show context (lines around change)
    diff -u textfile1 textfile2 # Better version, the most common
    diff -y textfile1 textfile2 # In two columns comparing both files
    colordiff # Same usage and parameters as previous, colored output
    diff -u textfile1 textfile2 | view - # Launches vim (exit by :q! Enter)
    vimdiff # Can show more colors, launches vim (exit by :q! Enter)
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Joining}
  \begin{bashcode}
    # Join compares every lines and creates all combinations -
    # ensure to have sorted input files with unique text
    # Compare two sorted text files and write shared lines
    # (duplicitous lines are shown just once)
    join textfile1 textfile2
    # Add file to the end of another text file
    cat file1 >> file2 # file2 will contain both files, file1 is unchanged
    # Add second file as second column
    paste file1 file2 > outputfile
    # Output will contain two columns (consisting of file1 and file2)
    # separated by TAB
  \end{bashcode}
\end{frame}

\subsection{Editors} 

\begin{frame}[fragile]{Editors}
\begin{itemize}
 \item \texttt{nano}, \texttt{pico} and \texttt{mc} are very simple, just for very basic text editing in command line or until you learn \texttt{vim} (graphical version is \textbf{gVim}) or \texttt{emacs} (graphical version is also available, just search for \textbf{Emacs} in your distribution software manager)
 \item You can work most of the time in graphical editors (slide \ref{editors})
 \item Emacs and Vim are extremely rich, but having completely different approach -- when you get use to one, you can't use the another
\end{itemize}
  \begin{bashcode}
    nano textfile # Basic simple text editor
    pico textfile # Clone of nano, same basic thing
    mc # Use its internal editor, just very basic
    emacs textfile # Extremely feature rich (including file browser
                   # and many tools), Exit by Ctrl+X and Ctrl+C
    vim textfile # Probably the most common, as rich as Emacs
    vimtutor # Launch tutorial to learn Vim (in various languages)
   \end{bashcode}
\end{frame}

\begin{frame}{Vim}
\begin{itemize}
 \item Modes of \texttt{vim}:
  \begin{enumerate}
   \item ``Normal'' -- nothing is displayed in bottom left corner, every key has some meaning (\texttt{dd} to cut current line, \texttt{r} to replace character below cursor, \texttt{v} for selection of text, \texttt{y} to copy, \texttt{x} to cut, \texttt{p} to paste, \texttt{i} or \texttt{Insert} key to enter insert mode, \texttt{:} to enter command mode, number to get to line of particular line number, \texttt{u} to undo last change(s),~\ldots)
   \item Insert -- in bottom left corner ``\texttt{-- INSERT --}'' is displayed -- the most familiar mode -- normal typing etc., exit to normal mode by \texttt{ESC} key
   \item Command -- in bottom left corner \texttt{:} is displayed -- awaits commands, e.g. \texttt{w} to write file, \texttt{q} to quit, \texttt{q!} to quit and discard changes, \%s/... to search and replace as in \texttt{sed}, \texttt{syntax on/off} to turn syntax highlight on/off, \texttt{/} to search,~\ldots{ }Exit to command mode by \texttt{Backspace} key (delete ``\texttt{:}'').
  \end{enumerate}
  \item For more information see \url{http://www.vim.org/} and \url{http://vim.wikia.com/wiki/Vim_Tips_Wiki}
  \item In Czech \url{http://www.nti.tul.cz/~satrapa/docs/vim/}
\end{itemize}
\end{frame}

\subsection{Regular expressions}

\begin{frame}{Regular expressions are useful\ldots}
  \begin{multicols}{2}
    \begin{center}
      \includegraphics[height=5.5cm]{regular_expressions.png}
    \end{center}
    \columnbreak
    \begin{itemize}
      \item Find text according to a~pattern
      \item Manipulate the text -- flip, reformat, replace,~\ldots
      \item Syntax is variable among programming languages and applications
      \item Probably the most advanced is Perl
    \end{itemize}
    \vfill
    \url{https://xkcd.com/208/}
  \end{multicols}
\end{frame}

\begin{frame}[allowframebreaks]{Regular expressions}
\label{regexp}
\begin{itemize}
  \item \alert{.} -- any single character
  \item \alert{*} -- any number of characters/occurrences of pattern (including 0)
  \item \alert{+} -- one or more occurrences of the preceding reg exp
  \item \alert{?} -- zero or one occurrences of the preceding reg exp
  \item \alert{[\ldots]} -- any character in the brackets
  \item \alert{[\textasciicircum\ldots]} -- reverse case -- all characters except newline and those listed in brackets
  \item \alert{\textasciicircum} -- first character of reg exp -- beginning of the line
  \item \alert{\$} -- last character of reg exp -- end of the line
  \item \alert{\textbackslash\{n,m\textbackslash\}} -- range of occurrences of single character
  \item \alert{\textbackslash\{n\textbackslash\}} -- exactly \textit{n} occurrences
  \item \alert{\textbackslash\{n,\textbackslash\}} -- at least \textit{n} occurrences
  \item \alert{\textbackslash} -- escape following special character
  \item \alert{|} -- either the preceding or following reg exp can be matched (alternation)
  \item \alert{\textbackslash(\ldots\textbackslash)} -- group reg exp (numbered, starting with 1) -- can be called by \alert{\textbackslash\textit{n}}, where \textit{n} is number of the group (starting with 1)
  \item \alert{\textbackslash$<$ \textbackslash$>$} -- word boundary
  \item \alert{[[:alnum:]]} -- alphanumerical characters (includes white space), same like \alert{[a-zA-Z0-9]}
  \item \alert{[[:alpha:]]} -- alphabetic characters, like \alert{[a-zA-Z]}
  \item \alert{[[:blank:]]} -- space and TAB
  \item \alert{[[:cntrl:]]} -- control characters
  \item \alert{[[:digit:]]} -- numeric characters, like \alert{[0-9]}
  \item \alert{[[:graph:]]} -- printable and visible (non-space) characters
  \item \alert{[[:lower:]]} -- lowercase characters, like \alert{[a-z]}
  \item \alert{[[:print:]]} -- printable characters (includes white space)
  \item \alert{[[:punct:]]} -- punctuation characters
  \item \alert{[[:space:]]} -- white space characters
  \item \alert{[[:upper:]]} -- uppercase characters, like \alert{[A-Z]}
  \item \alert{[[:xdigit:]]} -- hexadecimal digits
  \item \alert{\textasciicircum\$} -- blank line
  \item \alert{\textasciicircum.*\$} -- entire line whatever it is
  \item \alert{ *} -- one or more spaces (there is space before asterisk)
  \item \alert{\&} -- content of pattern that was matched
  \item Implementation in \texttt{vim}, \texttt{sed}, \texttt{grep}, \texttt{awk} and \texttt{perl} and among various UNIX systems is almost same, but not identical\ldots
  \item \textbf{grep}, \textbf{sed} and \textbf{vim} require escaping of \alert{+}, \alert{?}, \alert{\{}, \alert{\}}, \alert{(} and \alert{)} -- \textbf{egrep} (extended version, launched as \texttt{grep -E \ldots} or \texttt{egrep \ldots}) and \textbf{perl} not
  \item Read \url{http://www.regular-expressions.info/}, in Czech \url{http://www.nti.tul.cz/~satrapa/docs/regvyr/}, \url{http://www.root.cz/serialy/regularni-vyrazy/} and \url{http://www.regularnivyrazy.info/}, and manuals for Grep, Vim, Sed, Awk, Perl,~\ldots
  \item Mac OS~X has by default very outdated version of \texttt{sed} and another tools -- it does not have all advanced features -- users need to install e.g. \texttt{gnu-sed} formulae from \href{http://brew.sh/}{Homebrew}
\end{itemize}
\end{frame}

\section{Scripting}

\subsection{Basic skeleton}

\begin{frame}[fragile]{Basic script}
\begin{itemize}
 \item Every script begins with \texttt{\#!/bin/bash} (or alternative for another shells, Perl,~\ldots)
 \item Add any commands you like\ldots
 \item Every script should end with \texttt{exit} (but it is not necessary)
 \item After writing the script, add execution permission (\texttt{chmod o+x noninteractive.sh} or \texttt{chmod +x noninteractive.sh})
 \item The most simple script:
\end{itemize}
  \begin{bashcode}
    #!/bin/bash
    # Simple non-interactive script - no communication with user
    # only list of commands
    echo "Hi, $USER, today is `date` and your PATH is $PATH."
    echo
    exit
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Functions in BASH}
  \begin{itemize}
    \item Pieces of code, which can be used repeatedly
  \end{itemize}
  \begin{bashcode}
    # Declare new function
    function MyNewFunction1 {
      echo "Hello, $USER on $HOSTNAME!"
      }
    # Use it in a script as any other command:
    ...
    MyNewFunction1
    ...
    # Use with variables (same as in previous cases)
    function MyNewFunction2 {
      echo "The sum is `expr $1 + $2`."
      }
    # Use it in the script
    ...
    MyNewFunction2 5 8 # For example
    ...
  \end{bashcode}
\end{frame}

\subsection{Reading variables}

\begin{frame}[fragile]{Script reading two variables}
  \begin{bashcode}
    #!/bin/bash
    # Arguments are read from command line as parameters of the script
    # Order has to be kept (well, not in this case, but generally yes)
    echo "Sum of two numbers $1 and $2 is `expr $1 + $2`."
    # "$#" is available every time and contains number of parameters
    # (variables) given to the script
    echo "Number of parameters is $#."
    # "$*" is available every time and contains all supplied parameters
    echo "Those parameters were supplied: $*."
    #  "$0" is available every time and contains script path
    echo "Path to the scrip is: \"$0\"."
    echo
    exit
  \end{bashcode}
\vfil
When done, do:
\vfil
  \begin{bashcode}
    chmod +x interactive1.sh
    ./interactive1.sh 8 9 # Or select any other two numbers
  \end{bashcode}
  \begin{itemize}
    \item There is no checking of input values, nothing advanced,~\ldots
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Variables will be interactively provided by the user}
  \begin{bashcode}
    #!/bin/bash
    # Arguments are read from user input (script asks for them)
    echo "Please, input first value to sum and press Enter"
    read V1
    echo "Please, input second value to sum and press Enter"
    read V2
    echo "Sum of two numbers $V1 and $V2 is `expr $V1 + $V2` ."
    echo
    exit
  \end{bashcode}
\vfil
When done, do:
\vfil
  \begin{bashcode}
    chmod +x interactive2.sh
    ./interactive1.sh # Values will be provided when script asks
  \end{bashcode}
  \begin{itemize}
    \item There is no checking of input values, nothing advanced,~\ldots
  \end{itemize}
  \begin{bashcode}
    $(expr $1 + $2) # Alternative - $(...) is same as `...`
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Provide named parameters}
  \begin{bashcode}
    #!/bin/bash
    # Script has only one parameter ($1) provided as its parameter
    case "$1" in # evaluating provided parameter and behaving accordingly
      -d|--disk) # "|" means alternatives - more possible inputs
        echo "Your disk usage is:"
        df -h
        ;;
      -u|--uptime)
        echo "Your computer is running:"
        uptime
        ;;
      # This should be every time last possibility - any other input
      *) # User is then notified he entered nonsense and gets some help
        echo "Wrong option!"
        echo "Usage: -d or --disk for available disk space or"
        echo "-u or --uptime for computer uptime"
        exit 1;; # In this case, exit with error code 1
    esac
    exit
  \end{bashcode}
\end{frame}

\begin{frame}{Notes to previous script}
\begin{itemize}
 \item First make \texttt{interactive3.sh} executable and launch it via e.g. \texttt{./interactive3.sh -d} or \texttt{./interactive3.sh --uptime} or so
 \item Function \texttt{case} has basic checking of input available -- as last parameter use \texttt{*)} -- any other input except those defined above will produce some warning message, error or so
 \item In same way can be added more parameters (by multiple use of \texttt{case}), but order of parameters must be kept and all parameters are compulsory
 \item \texttt{case} can evaluate simple regular expressions, e.g. \texttt{--[Uu]ptime)}, \texttt{-d*},~\ldots
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Provide parameters, verify them and behave accordingly I}
  \begin{bashcode}
    #!/bin/bash
    NUMBER='^[0-9]+$' # From beginning (^) to the end ($) only number(s)
    function usagehelp { # Function to print help
      echo "Usage: number1 plus/minus/product/quotient number2"
      echo "Use plus for sum, minus for difference, product"
      echo "for multiplication or quotient for quotient."
      exit 1
      }
    if [ "$#" -ne "3" ]; then # Do we have 3 parameters provided?
        echo "Error! Requiring 3 parameters! Received $# ($*)."
        usagehelp # The function to print help
      fi
    if [[ ! $1 =~ $NUMBER ]]; then # Is parameter 1 number?
        echo "Parameter 1 is not an integer!"
        usagehelp # The function to print help
      fi
  \end{bashcode}
Continues on next slide\ldots
\end{frame}

\begin{frame}[fragile]{Provide parameters, verify them and behave accordingly II}
Remaining part from previous slide\ldots
  \begin{bashcode}
    if [[ ! $3 =~ $NUMBER ]]; then # Is parameter 3 number?
        echo "Parameter 3 is not an integer!"
        usagehelp # The function to print help
      fi
    case "$2" in
      plus) expr $1 '+' $3;;
      minus) expr $1 '-' $3;;
      product) expr $1 '*' $3;;
      quotient) expr $1 '/' $3;;
      *) echo "Wrong option!"
         usagehelp # The function to print help
         ;;
    esac
    exit
  \end{bashcode}
\vfil
\texttt{chmod +x interactive4.sh \&\& ./interactive4.sh 7 plus 5} (for example)
\end{frame}

\subsection{Branching the code}

\begin{frame}[fragile]{If branching}
  \begin{bashcode}
    # Basic variant - commands are done only if condition is met
    if expression; then
        commands
      fi
    # Two branches - when condition is met and when not
    if expression; then
        commands1 # expression is TRUE
      else
        commands2 # expression is FALSE - all other cases
      fi
    # Join together two (or more) if branches
    if expression1; then
        commands1
      elif expression2
        then
          commands2
        else
          commands3
        fi
  \end{bashcode}
\end{frame}

\begin{frame}[allowframebreaks]{Evaluation of conditions}
\begin{itemize}
  \item ``\texttt{[} \ldots~\texttt{]}'' (always keep space around it -- inside) is function to evaluate expressions (alternatively use command \texttt{test})
  \begin{itemize}
    \item \texttt{if [ "\$VAR" -eq 25 ]} or \texttt{test \$VAR -eq 25}
    \item \texttt{if [ "\$VAR" == "value" ]; \ldots}
    \begin{itemize}
      \item Escaping variables and values by double quotes (\texttt{"}\ldots\texttt{"}) is recommended (to be sure), but not strictly required all the time
    \end{itemize}
    \item \texttt{if [ ! -f regularfile ]; \ldots} -- reverted condition (\texttt{!})
    \item Single-bracket conditions -- file, string, or arithmetic conditions
    \item Double-bracket syntax -- enhanced
    \begin{itemize}
      \item Allow usage of regular expressions and globbing patterns
      \item Word splitting is prevented -- \texttt{\$STRINGVAR} can contain spaces
      \item Expanding file names -- \texttt{if [[ -a *.sh ]]} (variant with only one bracket doesn't work when there are multiple sh files)
      \item Allows more detailed test, e.g. \texttt{if [[ \$num -eq 3 \&\& "\$STRINGVAR" == XXX ]] \ldots}
    \end{itemize}
  \end{itemize}
  \item \texttt{-eq} -- Equal to
  \item \texttt{-lt} -- Less than
  \item \texttt{-gt} -- Greater than
  \item \texttt{-ge} -- Greater than or equal to
  \item \texttt{-le} -- Less than or equal to
  \item \texttt{-f \$FILE} -- True if \texttt{\$FILE} exists and is a regular file
  \item \texttt{-r \$FILE} -- True if \texttt{\$FILE} exists and is readable
  \item \texttt{-w \$FILE} -- True if \texttt{\$FILE} exists and is writable
  \item \texttt{-x \$FILE} -- True if \texttt{\$FILE} exists and is executable
  \item \texttt{-d \$FILE} -- True if \texttt{\$FILE} exists and is a directory
  \item \texttt{-s \$FILE} -- True if \texttt{\$FILE} exists and has a size greater than zero
  \item \texttt{-n \$STR} -- True if string \texttt{\$STR} is not a null string
  \item \texttt{-z \$STR} -- True if string \texttt{\$STR} is a null string
  \item \texttt{\$STR1 == \$STR2} -- True if both strings are equal
  \item \texttt{\$STR} -- True if string \texttt{\$STR} is assigned a value and is not null
  \item \texttt{\$STR1 != \$STR2} -- True if both strings are unequal
  \item \texttt{-a} -- Performs the \texttt{AND} function
  \item \texttt{-o} -- Performs the \texttt{OR} function
  \item Do not confuse globbing patterns and regular expressions when using \texttt{[[ \ldots~]]}
  \begin{itemize}
    \item Shell globbing: \texttt{if [[ "\$STRINGVAR" == ?[sS]tring* ]]; then} -- \texttt{?} represents single character \texttt{[]} any character inside and \texttt{*} zero or more characters
    \item Regular expressions: \texttt{if [[ "\$STRINGVAR" =$\sim$ .[sS]tring.* ]]; then} -- \texttt{.} represents single character (\texttt{?} would be zero or one occurrence of preceding expression), \texttt{[]} any character inside and \texttt{.*} zero or more occurrences of any single characters
  \end{itemize}
\end{itemize}
\end{frame}

\subsection{Loops}

\begin{frame}[fragile]{For, while and until cycles}
  \begin{bashcode}
    # One line for cycle for resizing of images
    for file in *.jpg; do convert $file -resize 100x100 thumbs-$file; done
    # More commands in a block
    for file in `ls -1 *.jpg`; do
      echo "Processing file $file"
      convert $file -resize 100x100 thumbs-$file
      echo thumbs-$file created
      done
    # while cycle is evaluating expression and if it is equal to 0
    # the cycle body is launched, repeatedly while the condition is met
    while expression
      do
        commands
      done
    # Like while cycle, but until expression is not equal to zero
    until expression; do
      commands
      done
  \end{bashcode}
\end{frame}

\section{Software}

\begin{frame}[allowframebreaks]{Package management}{Installation of software}
  \begin{itemize}
    \item Package -- an application or its part (documentation, plug-ins, translations,~\ldots)
    \item Packages are available in repositories (directories) on the internet
    \begin{itemize}
      \item System has list of applications available
      \item Updates and bug fixes are installed for all applications using one interface (GUI or command line) -- very reliable
      \item Packages are digitally signed -- security
      \item User can set custom repositories to get new packages
    \end{itemize}
    \item The most different task among distributions
    \item Packages have dependencies -- required shared libraries and so on -- use package manager and try to avoid downloading packages from the internet
    \item \alert{Read manual for your distribution!}
    \item Package is basically an archive and system has configured directories where to unpack it -- binaries are commonly in \texttt{/usr/bin/}, shared libraries in \texttt{/lib} and \texttt{/lib64} and rest in \texttt{/var}
    \item User should not care where parts of packages go to -- system is taking the care -- user can only damage it
    \item Shared libraries are installed automatically whenever some application needs them
    \item As all files are placed in standard defined directories, it is very simple to use them also for another applications
    \item Applications not available in repositories, neither as distributional package should be installed into \texttt{$\sim$/bin} for current user or \texttt{/usr/local} for all users (binaries then go into \texttt{bin} and so on)
  \end{itemize}
\end{frame}

\begin{frame}{Package management in command line in openSUSE and Debian/Ubuntu}
Root password is required: use \texttt{sudo \ldots} or \texttt{su -}
\begin{center}
\begin{tabular}{lll}
\textbf{Task} & \textbf{openSUSE} & \textbf{Debian/Ubuntu}\\
Package name & *.rpm & *.deb\\
Install & zypper in \textit{package} & apt-get install \textit{package}\\
Remove & zypper rm \textit{package} & apt-get remove \textit{package}\\
Refresh repositories & zypper ref & apt-get update\\
Update & zypper up & apt-get update\\
Upgrade & zypper dup & apt-get dist-upgrade\\
Search & zypper se \textit{term} & apt-cache search \textit{term}\\
Clear packages & rpmorphan & apt-get autoremove\\
Interactive manager & yast sw\_single & aptitude\\
Add repository & zypper ar \textit{repository} & nano /etc/apt/sources.list\\
Remove repository & zypper rm \textit{repository} & nano /etc/apt/sources.list
\end{tabular}
\end{center}
\end{frame}

\begin{frame}[fragile]{Basics of compilation}
\begin{itemize}
  \item Some software is distributed only as source code written in languages like C or C++ -- user has to compile it to get binary executable
  \item Compilation creates binary specific for particular operating system and hardware platform -- can be tuned for optimal performance
  \item Interpreted languages like Bash, Perl, Python or Java don't have to be compiled (but it is possible) -- they need their interpreter to run, relative easily portable among hardware platforms and OS
  \item Applications requiring compilation usually have good instructions
\end{itemize}
  \begin{bashcode}
    # General schema:
    configure # Many possible parameters, settings for compilation
              # Not required in every time
    make # Basic building command, sometimes only this is required
    make install # Final creation of binary, sometimes required
  \end{bashcode}
\begin{itemize}
  \item If you don't have to do it, don't do it. Solving problems can be complicated -- contact someone skilled or author of the application\ldots
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Compilation of RAxML}
\begin{footnotesize}
  Available from \url{https://github.com/stamatak/standard-RAxML} (cite \href{https://bioinformatics.oxfordjournals.org/content/30/9/1312.abstract}{Stamakis 2014}).
\end{footnotesize}
  \begin{bashcode}
    # Create working directory
    mkdir raxml
    # Go there
    cd raxml/
    # Get source code from GitHub (svn downloads only changed files)
    svn co https://github.com/stamatak/standard-RAxML/tags/v8.2.4
    # Go to newly created directory
    cd v8.2.4/
    ls # List files
    # No need of Windows version - delete it
    rm -rf Windows*
    # Compile standard version (other versions are available for better CPU)
    make -f Makefile.gcc
    # Remove unneeded files
    rm *.o
    # Launch it - see RAxML help
    ./raxmlHPC -h
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Launching Java applications}
\begin{itemize}
  \item \href{https://www.java.com/}{Java} is probably the most portable language working on any operating system -- the only condition is to install \href{https://en.wikipedia.org/wiki/Java_virtual_machine}{Java virtual machine (JVM)}
  \item Linux usually use \href{http://openjdk.java.net/}{OpenJDK} -- search for packages named \texttt{*openjdk*}
  \item Let's download e.g. \href{http://tree.bio.ed.ac.uk/software/figtree/}{FigTree} from \url{http://tree.bio.ed.ac.uk/download.php?id=90&num=3}
\end{itemize}
  \begin{bashcode}
    # Go to directory where you downloaded it
    cd directory/with/downloaded/figtree
    # Decompress downloaded archive
    tar zxvf FigTree_v1.4.2.tgz
    # Go to created directory
    cd FigTree_v1.4.2/
    ls * # List files, also in subdirectories
    # Launch it (command java launches *.jar files)
    java -jar lib/figtree.jar
    # Limit its memory usage to 512 MB
    java -Xmx512m -jar lib/figtree.jar
  \end{bashcode}
\end{frame}

% \begin{frame}{Launching of Windows and DOS applications in Linux}
%   \begin{itemize}
%     \item 
%   \end{itemize}
% \end{frame}

\section{MetaCentrum}

\subsection{Information}

\begin{frame}[allowframebreaks]{CESNET and MetaCentrum}
\begin{itemize}
  \item \href{https://www.cesnet.cz/?lang=en}{CESNET} is organization of Czech universities, Academy of Science and other organizations taking care about Czech backbone Internet, one of world leading institutions of this type
  \item CESNET provides various \href{https://www.cesnet.cz/services/?lang=en}{services}
  \begin{itemize}
    \item Massive computations -- \href{https://www.cesnet.cz/services/massive-computations-metacentrum/?lang=en}{MetaCentrum}
    \item Practically unlimited \href{https://www.cesnet.cz/services/data-storage/?lang=en}{data storage}
    \item \href{https://www.cesnet.cz/services/filesender/?lang=en}{FileSender} to be able to send up to 500~GB file
    \item \href{https://www.cesnet.cz/services/owncloud/?lang=en}{ownCloud} to backup and/or sync data across devices (default capacity is 100~GB)
    \begin{itemize}
      \item It is possible to connect by webDAV to ownCloud (slide \ref{transfers}) -- many applications support it
    \end{itemize}
    \item And \href{https://www.cesnet.cz/services/?lang=en}{more\ldots}
  \end{itemize}
  \item Services accessible without registration
  \begin{itemize}
    \item ownCloud \url{https://owncloud.cesnet.cz/}
    \item FileSender \url{https://filesender.cesnet.cz/}
    \item Go to web and log in with your institutional password
  \end{itemize}
  \item Services requiring registration (and approval)
  \begin{itemize}
    \item To use MetaCentrum fill registration form \url{https://metavo.metacentrum.cz/en/application/form}
    \item To use data storage fill registration form \url{https://einfra.cesnet.cz/perun-registrar-fed/?vo=storage&locale=en}
    \item Users not having access to \href{https://www.eduid.cz/en/index}{EduID} have to register first at HostelID \url{https://hostel.eduid.cz/en/index.html}
    \item Note some browser do not have required certificate and registration pages do not work correctly. \href{https://www.mozilla.org/firefox/}{Mozilla Firefox} should be safe choice every time.
  \end{itemize}
  \item Information about data storage \url{https://du.cesnet.cz/en/start} contains detailed usage instructions
  \item Information about MetaCentrum \url{https://www.metacentrum.cz/en/}
  \item Most of practical information for users are at wiki \url{https://wiki.metacentrum.cz/w/index.php?&setlang=en}
\end{itemize}
\end{frame}

\begin{frame}{MetaCentrum}
\begin{itemize}
  \item Also available is Galaxy \url{https://galaxy.metacentrum.cz/galaxy/} (same login as to MetaCentrum) -- web based bioinformatics framework (more information at \href{https://wiki.metacentrum.cz/wiki/Galaxy_application}{wiki})
  \item Current state and usage as available at \url{https://metavo.metacentrum.cz/en/}
  \item Manage your user account at \url{http://metavo.metacentrum.cz/en/myaccount/index.html}
  \item Personal view on actual resources and running tasks is at \url{https://metavo.metacentrum.cz/pbsmon2/person}
  \item List of available applications \url{https://wiki.metacentrum.cz/wiki/Kategorie:Applications}
  \item It has 8 front ends where users log and thousands of computers doing the calculations -- they are not accessed directly
  \item Most of computers are running \href{https://www.debian.org/}{Debian GNU/Linux}
\end{itemize}
\end{frame}

\subsection{Usage}

\begin{frame}[fragile]{MetaCentrum usage}
  \begin{itemize}
    \item User can transfer data on one of \href{https://wiki.metacentrum.cz/wiki/Frontend}{frontends} by \texttt{scp} or for example \href{https://winscp.net/}{WinSCP} from Windows
    \item Same credentials are used for all front ends, for SSH login as well as file transmissions
  \end{itemize}
  \begin{bashcode}
    # Login to selected server (tarkil is located in Prague)
    ssh -X USER@tarkil.cesnet.cz
    # Continue as in any other command line...
  \end{bashcode}
  \begin{itemize}
    \item In home directory on the server prepare all needed data and non-interactive script (interactive are more complicated) which will do the calculations
    \item Tasks are not launched immediately, but using \texttt{qsub} -- task is submitted into queue and system decides when it will be launched
  \end{itemize}
\end{frame}

\begin{frame}{File transfers to MetaCentrum}
  \begin{itemize}
    \item Graphical applications: \href{http://gftp.org/}{gFTP}, \href{https://filezilla-project.org/}{FileZilla} or from most of file managers
    \item Protocol is SSH/SSH2/SFTP/SCP, port 22, server is selected \href{https://wiki.metacentrum.cz/wiki/Frontend}{frontend's} address (e.g. \texttt{tarkil.cesnet.cz}) -- it is recommendable to use all the time same frontend
    \item All servers are accessible under domain \texttt{*.metacentrum.cz}: \texttt{skirit}, \texttt{perian}, \texttt{onyx}, \texttt{zuphux} (located in Brno), \texttt{nympha}, \texttt{minos} (in Pilsen), \texttt{hermes} (in České Budějovice) and \texttt{tarkil} (in Prague) -- so that e.g. \texttt{tarkil.cesnet.cz} is synonymous to \texttt{tarkil.metacentrum.cz}
    \item See slide \ref{transfers} and following to command-line transfers of files
  \end{itemize}
  \includegraphics[width=\textwidth]{gftp.png}
\end{frame}

\subsection{Tasks}

\begin{frame}[fragile]{Basic skeleton of script running tasks I}
  \begin{bashcode}
    #!/bin/bash
    # Modify the script according to your needs!
    # Set data directories
    WORKDIR="bayes_batch"
    DATADIR="/storage/praha1/home/$LOGNAME"
    # So there is directory /storage/praha1/home/gunnera/bayes_batch
    # (in this case) containing all the data needed for calculations
    # Clean-up of SCRATCH (it is temporal directory created by server) -
    # the commands will be launched on the end when the job is done
    trap 'clean_scratch' TERM EXIT
    trap 'cp -ar $SCRATCHDIR $DATADIR/ && clean_scratch' TERM
    # Prepare the task - copy all needed files from working directory
    # into particular computer which will finally do the calculations
    cp -ar $DATADIR/$WORKDIR/* $SCRATCHDIR/  || exit 1
    # Change working directory - script goes to the directory where
    # calculations are done
    cd $SCRATCHDIR/ || exit 2 # If it fails, exit script
  \end{bashcode}
Ends on following slide\ldots
\end{frame}

\begin{frame}[fragile]{Basic skeleton of script running tasks II}
\ldots begins on previous slide.
\vfil
  \begin{bashcode}
    # Prepare calculations - load required application modules
    # See https://wiki.metacentrum.cz/wiki/Kategorie:Applications
    # Every application module is loaded by "module add XXX"
    . /packages/run/modules-2.0/init/sh
    module add parallel # In this case GNU Parallel and MrBayes
    module add mrbayes-3.2.4
    # Launch the analysis - calculate MrBayes for multiple files
    # Note Parallel will distribute task among 8 CPU threads (-j 8),
    # so that qsub must in this case contain nodes=1:ppn=8 (see further)
    ls -1 *.nexus | parallel -j 8 'mb {} | tee -a {}.log'
    # Copy results back to home directory
    cp -ar $SCRATCHDIR $DATADIR/$WORKDIR || export CLEAN_SCRATCH=false
    # This is all needed, the script is ready to be launched...
    exit
  \end{bashcode}
  \begin{itemize}
    \item Make \texttt{metacentrum.sh} executable and modify it to fit your needs\ldots
    \item If it was written on Windows, convert EOL (and encoding)\ldots
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Launching of tasks}
\begin{itemize}
  \item \url{https://wiki.metacentrum.cz/wiki/Running_jobs_in_scheduler}
  \item Personal view \url{https://metavo.metacentrum.cz/pbsmon2/person} has nice overview of available resources and tasks and allows comfortable construction of submission command
\end{itemize}
  \begin{bashcode}
    # We will run up to 5 days, require 4 GB of RAM, 5 GB of disk space, one
    # physical computer with 8 CPU threads and we get all information mails
    qsub -l walltime=5d -l mem=4gb -l scratch=5gb -l nodes=1:ppn=8 -m abe \
      bayes_batch.sh
    # Check how the task is running (above web) and
    qstat | grep $USER
    qstat -u $USER
    qstat 123456789 # The task ID is available from commands above or mail
    qstat -f 123456789 # Print a lot of details
    qdel 123456789 # Terminate scheduled or running task
    qfree # List available resources
  \end{bashcode}
\end{frame}

\begin{frame}{Common problems with launching the tasks}
  \begin{itemize}
    \item Script fails because of wrong PATH or missing file -- ensure all needed files are transferred and applications receive correct paths
    \begin{itemize}
      \item Do not use absolute paths (starting with \texttt{/}) -- only relative
    \end{itemize}
    \item Not all required applications are correctly loaded
    \begin{itemize}
      \item Check \href{https://wiki.metacentrum.cz/wiki/Kategorie:Applications}{wiki} and load all needed applications
      \item Names of binaries are commonly little bit different -- contain names of versions etc
    \end{itemize}
    \item Estimation of time needed to run the task
    \begin{itemize}
      \item No really good solution\ldots
      \item Make some trials and try to estimate\ldots
      \item There are very different CPUs available (with different speeds) -- it is possible to require particular CPU type (but it reduces number of available nodes\ldots)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Get to task's working directory}
\begin{itemize}
  \item Go to \url{https://metavo.metacentrum.cz/pbsmon2/person} and click to list of your tasks and click to selected task
  \item Search for information \textbf{exec\_host} (address of node doing the task) and \textbf{SCRATCHDIR} (temporal directory for all data and results)
  \item Sometimes one needs to monitor task progress or influence it
  \item It is not possible to directly modify running task, but at least check (and possibly modify) input data and see outputs
\end{itemize}
  \begin{bashcode}
    # From MetaCentrum frontend login to respective node running the task
    ssh exec_host # No need to specify user name
    # Go to SCRATCH directory
    cd SCRATCHDIR
    # There are working data of currently running task...
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{Interactive tasks}
\begin{itemize}
  \item See information at \url{https://wiki.metacentrum.cz/wiki/Interactive_job}
\end{itemize}
  \begin{bashcode}
    # Again launch qsub according to actual needs
    # Note "-I" for interactive session and missing script name
    qsub -I -l walltime=2h -l nodes=1:ppn=1 -l mem=2gb
    # Wait for job to start..
    # After we get the interactive task, we are on new server
    hostname # See where we are - we can connect to that server directly
    ssh USER@given.server.cz # User name and password are the same
                             # Server address is output from "hostname"
    screen # Secure we can log off in the meantime
  \end{bashcode}
\begin{itemize}
  \item Work as on normal Linux server\ldots
  \item With \texttt{screen} we can disconnect as usually and let tasks run in background
\end{itemize}
\end{frame}

\subsection{Graphical connection}

\begin{frame}[fragile]{Graphical interactive task}
\begin{itemize}
  \item See information at \url{https://wiki.metacentrum.cz/wiki/Remote_desktop}
\end{itemize}
  \begin{bashcode}
    # Again launch qsub according to actual needs
    # Note "-I" for interactive session and missing script name
    qsub -I -l walltime=2h -l nodes=1:ppn=1 -l mem=2gb
    # Wait for job to start..
    # After we get the interactive task, we are on new server
    screen # Secure we can log off in the meantime
    module add gui # We need to add GUI module
    gui start # Start GUI (see above link for details)
    gui info -p # Print information about running VNC sessions
                # Including address, port and password to connect
  \end{bashcode}
\begin{itemize}
  \item Launch your favorite VNC client (\href{https://www.kde.org/applications/internet/krdc/}{KRDC}, \href{http://www.tightvnc.com/}{TightVNC},~\ldots) and use credentials from above output to connect
  \item Work as on normal Linux desktop\ldots
  \item With \texttt{screen} we can disconnect as usually
\end{itemize}
\end{frame}

\begin{frame}{Running VNC}
\includegraphics[width=\textwidth]{vnc.png}
\end{frame}

\section{Administration}

\subsection{File systems}

\begin{frame}[allowframebreaks]{Creation and control of FS}
\begin{itemize}
  \item \texttt{fdisk -l} lists disks and partitions
  \item To manage disk partitioning use \texttt{fdisk /dev/sdX} (doesn't support GPT very well yet) or \texttt{gdisk /dev/sdX}
  \item When hard drive is partitioned, partitions must be formatted
  \item Commands \texttt{mkfs.*} create various FS, common syntax is \texttt{mkfs.XXX -parameters /dev/sdXY}, where sdXY is particular disk partition
  \item Parameters can set label and various settings of behavior of the disk partition, check \texttt{man mkfs.XXX}
  \item To check FS for errors use \texttt{fsck.XXX /dev/sdXY} (according to respective FS)
  \item \texttt{tune2fs -parameters /dev/sdXY} can set various parameters to influence behavior of disk partition
  \item \texttt{hdparm -parameters /dev/sdX} can set advanced hardware parameters of hard drive
  \item The most convenient is using graphical tools available in all distributions\ldots
  \begin{itemize}
    \item in openSUSE there is YaST administrative module -- from command line launch \texttt{yast --qt disk} for graphical or \texttt{yast disk} for text-based version
    \item All distributions have graphical tools like \href{http://gparted.org/}{GParted} where it is possible to comfortable manage disks
  \end{itemize}
  \item \texttt{df -h} shows available/occupied space on disks/partitions, but because of special features of Btrfs it doesn't show every time correct values for this FS -- it is better to use \texttt{btrfs fi df /mount/point} (\texttt{/mount/point} use to be the most commonly \texttt{/})
\end{itemize}
\end{frame}

% \begin{frame}{Btrfs and Snapper}
%   \begin{itemize}
%     \item 
%   \end{itemize}
% \end{frame}

\subsection{System services}

\begin{frame}[fragile]{Managing system services}
\begin{itemize}
  \item Different among distributions -- several main methods
  \item Most common is \href{https://wiki.freedesktop.org/www/Software/systemd/}{SystemD}, less common older init scripts and RC scripts
  \item Used to manage services like web server, database,~\ldots
  \item \alert{Read documentation for your distribution!}
  \item All actions require root authentication
\end{itemize}
  \begin{bashcode}
    # SystemD - huge amount of possibilities
    systemctl enable/disable/status/start/stop servicename # TAB helps
    # RC scripts
    rcservicename status/start/stop # TAB helps to select service
    # Init scripts
    /etc/init.d/servicename status/start/stop # TAB helps to select service
  \end{bashcode}
\end{frame}

\begin{frame}[fragile]{SystemD usage}
  \begin{bashcode}
    # List installed services and their status
    systemctl list-units --type service
    # Enable/disable/see status/start/stop service
    systemctl enable/disable/status/start/stop servicename # TAB helps
    # Show overriden config files
    systemd-delta
    # Analyze boot time (how long does each service take to start)
    systemd-analyze blame # Text output
    systemd-analyze plot > filename.svg # Same in graphics
    # Log for particular service
    journalctl -u servicename
    # Last logged messages (press Ctrl+C to exit)
    journalctl -f
    # Log records since last boot
    journalctl -b
    # Time and date information and management
    timedatectl
  \end{bashcode}
\end{frame}

% \section{Git}

% \begin{frame}[fragile]{Git and GitHub}
%   \begin{bashcode}
%     #
%   \end{bashcode}
% \end{frame}

\section{The end}

% \subsection{Switching to Linux}

% \begin{frame}{Brief list of applications to help to switch to Linux}
% \begin{itemize}
%   \item 
% \end{itemize}
% \end{frame}

% \subsection{Resources}

% \begin{frame}{}
% \begin{itemize}
%   \item 
% \end{itemize}
% \end{frame}

% \subsection{The very end}

\begin{frame}{The end}{Our course is over\ldots}
\begin{center}
  \ldots I hope it was helpful for You\ldots\\
  \vfill
  \ldots any feedback is welcomed\ldots
  \vfill
  \ldots happy Linux hacking\ldots
  \vfill
  \ldots any final questions?
  \vfill
\end{center}
\begin{flushright}
  \begin{tiny}
   \href{https://en.wikipedia.org/wiki/XeTeX}{Typesetting} using \XeLaTeX~on \href{https://www.opensuse.org/}{openSUSE} \href{https://en.wikipedia.org/wiki/GNU}{GNU}/\href{https://en.wikipedia.org/wiki/Linux}{Linux} \today
  \end{tiny}
\end{flushright}
\end{frame}

\end{document}

% % Missing topics
% * How to break system :-)
% * Security, antiviruses
% * More examples about software on MetaCentrum, scripts (on MetaCentrum)
% * More about regular expressions
% * VirtualBox shared folders
% * Filtering of user inputs
